{"version":3,"file":"fdlib.js","sources":["../src/helpers.js","../src/constants.js","../src/assert.js","../src/domain/domain_lib.js","../src/domain/domain_plus.js","../src/domain/domain_minus.js","../src/trie.js"],"sourcesContent":["// FDlib Helpers\n\nconst INSPECT =\n  typeof require === 'function'\n    ? function(arg) {\n        return require('util')\n          .inspect(arg, { showHidden: false, depth: 100 })\n          .replace(/\\n ?/g, ' ');\n      }\n    : function(o) {\n        return `${o}`;\n      };\n\nlet TERM = console;\nfunction setTerm(newTerm) {\n  TERM = { ...TERM, ...newTerm };\n}\n\nfunction getTerm() {\n  return TERM;\n}\n\nfunction _doNothing() {}\n\nfunction SUSH() {\n  const prevTerm = TERM;\n  setTerm({\n    log: _doNothing,\n    warn: _doNothing,\n    error: _doNothing,\n    trace: _doNothing,\n    time: _doNothing,\n    timeEnd: _doNothing,\n  });\n  return prevTerm;\n}\n\n// Abstraction for throwing because throw statements cause deoptimizations\n// All explicit throws should use this function. Also helps with tooling\n// later, catching and reporting explicit throws and whatnot.\n\nfunction THROW(...msg) {\n  throw new Error(msg.join(': '));\n}\n\nexport { INSPECT, SUSH, THROW, getTerm, setTerm };\n","import { getTerm, THROW } from './helpers';\n\nconst SUB = 0; // WARNING: don't change this. It's mostly a magic number thing.\nconst SUP = 100000000; // Don't let this max exceed 30 bits or stuff will break\nconst NOT_FOUND = -1;\n\n// Different from NOT_FOUND in that NOT_FOUND must be -1 because of the indexOf api\n// while NO_SUCH_VALUE must be a value that cannot be a legal domain value (<SUB or >SUP)\nconst NO_SUCH_VALUE = Math.min(0, SUB) - 1; // Make sure NO_SUCH_VALUE is a value that may be neither valid in a domain nor >=0\n\nconst ARR_RANGE_SIZE = 2; // Magic number\n\nconst SMALL_MAX_NUM = 30;\n// There are SMALL_MAX_NUM flags. if they are all on, this is the number value\n// (oh and; 1<<31 is negative. >>>0 makes it unsigned. this is why 30 is max.)\nconst SOLVED_FLAG = (1 << 31) >>> 0; // The >>> makes it unsigned, we dont really need it but it may help perf a little (unsigned vs signed)\n\nconst $STABLE = 0;\nconst $CHANGED = 1;\nconst $SOLVED = 2;\nconst $REJECTED = 3;\n\nif (process.env.NODE_ENV !== 'production') {\n  if (SMALL_MAX_NUM > 30) {\n    const msg =\n      'SMALL_MAX_NUM cannot exceed 30 or else shifting fails above and elsewhere';\n    getTerm().error(msg);\n    THROW(msg);\n  }\n\n  if (NOT_FOUND !== NO_SUCH_VALUE) {\n    const msg =\n      'not found constants NOT_FOUND and NO_SUCH_VALUE need to be equal to prevent confusion bugs';\n    getTerm().error(msg);\n    THROW(msg);\n  }\n}\n\nexport {\n  $CHANGED,\n  $REJECTED,\n  $SOLVED,\n  $STABLE,\n  NOT_FOUND,\n  NO_SUCH_VALUE,\n  ARR_RANGE_SIZE,\n  SMALL_MAX_NUM,\n  SOLVED_FLAG,\n  SUB,\n  SUP,\n};\n","// Assert helper library. This should not be in production\n\nimport { getTerm, THROW } from './helpers';\n\nimport { SUB, SUP, SMALL_MAX_NUM, SOLVED_FLAG } from './constants';\n\nfunction ASSERT(bool, msg = '', ...args) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (bool) {\n      return;\n    }\n\n    if (!msg) msg = '(no desc)'; // Msg = new Error('trace').stack;\n\n    const TERM = getTerm();\n\n    TERM.error(`Assertion fail: ${msg}`);\n    if (args) {\n      TERM.log('Error args:', args);\n    }\n    //      TERM.trace()\n    //      process.exit() # uncomment for quick error access :)\n\n    const suffix =\n      args && args.length > 0\n        ? `Args (${args.length}x): \\`${_stringify(args)}\\``\n        : '';\n\n    THROW(`Assertion fail: ${msg} ${suffix}`);\n  }\n}\n\nfunction _stringify(o) {\n  if (Array.isArray(o)) {\n    return `[ ${o.map(_stringify).join(', ')} ]`;\n  }\n\n  return `${o}`;\n}\n\n// Simple function to completely validate a domain\n\nfunction ASSERT_STRDOM(domain, expectSmallest, domain__debug) {\n  if (process.env.NODE_ENV !== 'production') {\n    const s = domain__debug && domain__debug(domain);\n    const strdomValueLen = 2;\n    const strdomRangeLen = 2 * strdomValueLen;\n    ASSERT(typeof domain === 'string', 'ONLY_STRDOM', s);\n    ASSERT(domain.length % strdomRangeLen === 0, 'SHOULD_CONTAIN_RANGES', s);\n    const lo = (domain.charCodeAt(0) << 16) | domain.charCodeAt(1);\n    const hi =\n      (domain.charCodeAt(domain.length - strdomValueLen) << 16) |\n      domain.charCodeAt(domain.length - strdomValueLen + 1);\n    ASSERT(lo >= SUB, 'SHOULD_BE_GTE ' + SUB, s);\n    ASSERT(hi <= SUP, 'SHOULD_BE_LTE ' + SUP, s);\n    ASSERT(\n      !expectSmallest || lo !== hi || domain.length > strdomRangeLen,\n      'SHOULD_NOT_BE_SOLVED',\n      s\n    );\n    return true;\n  }\n}\n\nfunction ASSERT_SOLDOM(domain, value) {\n  if (process.env.NODE_ENV !== 'production') {\n    ASSERT(typeof domain === 'number', 'ONLY_SOLDOM');\n    ASSERT(domain >= 0, 'ALL_SOLDOMS_SHOULD_BE_UNSIGNED');\n    ASSERT(domain >= SOLVED_FLAG, 'SOLDOMS_MUST_HAVE_FLAG_SET');\n    ASSERT((domain ^ SOLVED_FLAG) >= SUB, 'SOLVED_NUMDOM_SHOULD_BE_MIN_SUB');\n    ASSERT((domain ^ SOLVED_FLAG) <= SUP, 'SOLVED_NUMDOM_SHOULD_BE_MAX_SUP');\n    if (value !== undefined)\n      ASSERT((domain ^ SOLVED_FLAG) === value, 'SHOULD_BE_SOLVED_TO:' + value);\n    return true;\n  }\n}\n\nfunction ASSERT_BITDOM(domain) {\n  if (process.env.NODE_ENV !== 'production') {\n    ASSERT(typeof domain === 'number', 'ONLY_BITDOM');\n    ASSERT(domain >= 0, 'ALL_BITDOMS_SHOULD_BE_UNSIGNED');\n    ASSERT(domain < SOLVED_FLAG, 'SOLVED_FLAG_NOT_SET');\n    ASSERT(SMALL_MAX_NUM < 31, 'next assertion relies on this');\n    ASSERT(\n      domain >= 0 && domain < (1 << (SMALL_MAX_NUM + 1)) >>> 0,\n      'NUMDOM_SHOULD_BE_VALID_RANGE'\n    );\n    return true;\n  }\n}\n\nfunction ASSERT_ARRDOM(domain, min, max) {\n  if (process.env.NODE_ENV !== 'production') {\n    ASSERT(Array.isArray(domain), 'ONLY_ARRDOM');\n    if (domain.length === 0) return;\n    ASSERT(domain.length % 2 === 0, 'SHOULD_CONTAIN_RANGES');\n    ASSERT(domain[0] >= (min || SUB), 'SHOULD_BE_GTE ' + (min || SUB));\n    ASSERT(\n      domain[domain.length - 1] <= (max === undefined ? SUP : max),\n      'SHOULD_BE_LTE ' + (max === undefined ? SUP : max)\n    );\n    return true;\n  }\n}\n\nfunction ASSERT_NORDOM(domain, expectSmallest, domain__debug) {\n  if (process.env.NODE_ENV !== 'production') {\n    const s = domain__debug && domain__debug(domain);\n    ASSERT(\n      typeof domain === 'string' || typeof domain === 'number',\n      'ONLY_NORDOM',\n      s\n    );\n    if (typeof domain === 'string') {\n      ASSERT(domain.length > 0, 'empty domains are always numdoms');\n      if (expectSmallest) {\n        const lo = (domain.charCodeAt(0) << 16) | domain.charCodeAt(1);\n        const hi =\n          (domain.charCodeAt(domain.length - 2) << 16) |\n          domain.charCodeAt(domain.length - 1);\n        ASSERT(\n          hi > SMALL_MAX_NUM,\n          'EXPECTING_STRDOM_TO_HAVE_NUMS_GT_BITDOM',\n          s\n        );\n        ASSERT(\n          domain.length > 4 || lo !== hi,\n          'EXPECTING_STRDOM_NOT_TO_BE_SOLVED'\n        );\n      }\n\n      return ASSERT_STRDOM(domain, undefined, undefined, s);\n    }\n\n    if (expectSmallest)\n      ASSERT(\n        !domain || domain >= SOLVED_FLAG || (domain & (domain - 1)) !== 0,\n        'EXPECTING_SOLVED_NUMDOM_TO_BE_SOLDOM',\n        s\n      );\n    ASSERT_NUMDOM(domain, s);\n    return true;\n  }\n}\n\nfunction ASSERT_NUMDOM(domain, expectSmallest, domain__debug) {\n  if (process.env.NODE_ENV !== 'production') {\n    const s = domain__debug && domain__debug(domain);\n    ASSERT(typeof domain === 'number', 'ONLY_NUMDOM', s);\n    if (expectSmallest)\n      ASSERT(\n        !domain || domain >= SOLVED_FLAG || (domain & (domain - 1)) !== 0,\n        'EXPECTING_SOLVED_NUMDOM_TO_BE_SOLDOM',\n        s\n      );\n    if (domain >= SOLVED_FLAG) ASSERT_SOLDOM(domain);\n    else ASSERT_BITDOM(domain);\n    return true;\n  }\n}\n\nfunction ASSERT_ANYDOM(domain) {\n  if (process.env.NODE_ENV !== 'production') {\n    ASSERT(\n      typeof domain === 'string' ||\n        typeof domain === 'number' ||\n        Array.isArray(domain),\n      'ONLY_VALID_DOM_TYPE'\n    );\n  }\n}\n\nfunction ASSERT_VARDOMS_SLOW(vardoms, domain__debug) {\n  if (process.env.NODE_ENV !== 'production') {\n    for (const domain of vardoms) {\n      ASSERT_NORDOM(domain, true, domain__debug);\n    }\n  }\n}\n\nconst LOG_NONE = 0;\nconst LOG_STATS = 1;\nconst LOG_SOLVES = 2;\nconst LOG_MIN = LOG_NONE;\nconst LOG_MAX = LOG_SOLVES;\n\nconst LOG_FLAG_NONE = 0;\nconst LOG_FLAG_PROPSTEPS = 1;\nconst LOG_FLAG_CHOICE = 2;\nconst LOG_FLAG_SEARCH = 4;\nconst LOG_FLAG_SOLUTIONS = 8;\n\nlet LOG_FLAGS = LOG_FLAG_NONE; // LOG_FLAG_PROPSTEPS|LOG_FLAG_CHOICE|LOG_FLAG_SOLUTIONS|LOG_FLAG_SEARCH;\n// let LOG_FLAGS = LOG_FLAG_PROPSTEPS|LOG_FLAG_CHOICE|LOG_FLAG_SOLUTIONS|LOG_FLAG_SEARCH;\nfunction ASSERT_SET_LOG(level) {\n  if (process.env.NODE_ENV !== 'production') {\n    LOG_FLAGS = level;\n  }\n}\n\nfunction helper_logger(...args) {\n  if (process.env.NODE_ENV !== 'production') {\n    getTerm().log('LOG', ...args);\n  }\n}\n\nfunction ASSERT_LOG(flags, func) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (flags & LOG_FLAGS) {\n      ASSERT(typeof func === 'function');\n      func(helper_logger);\n    }\n  }\n}\n\nlet TRACING = false;\nfunction isTracing() {\n  if (process.env.NODE_ENV !== 'production') {\n    return TRACING;\n  }\n\n  return false;\n}\n\nfunction setTracing(b) {\n  if (process.env.NODE_ENV !== 'production') {\n    TRACING = b;\n  }\n}\n\n/**\n * @return {boolean}\n */\nfunction TRACE(...args) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (args.length === 1 && args[0] === '') return false;\n    if (TRACING) getTerm().log(...args);\n    return false;\n  }\n}\n\nfunction TRACE_MORPH(from, to, desc, names, indexes) {\n  if (process.env.NODE_ENV !== 'production') {\n    TRACE(' ### Morphing;    ', from, '   ==>    ', to);\n  }\n}\n\nfunction TRACE_SILENT(...args) {\n  if (process.env.NODE_ENV !== 'production') {\n    TRACE('\\u001B[90m', ...args, '\\u001B[0m');\n  }\n}\n\nexport {\n  ASSERT,\n  ASSERT_ANYDOM,\n  ASSERT_ARRDOM,\n  ASSERT_BITDOM,\n  ASSERT_NORDOM,\n  ASSERT_NUMDOM,\n  ASSERT_SOLDOM,\n  ASSERT_STRDOM,\n  ASSERT_VARDOMS_SLOW,\n  ASSERT_LOG,\n  ASSERT_SET_LOG,\n  LOG_FLAG_CHOICE,\n  LOG_FLAG_NONE,\n  LOG_FLAG_PROPSTEPS,\n  LOG_FLAG_SEARCH,\n  LOG_FLAG_SOLUTIONS,\n  LOG_MAX,\n  LOG_MIN,\n  LOG_NONE,\n  LOG_SOLVES,\n  LOG_STATS,\n  TRACE,\n  TRACE_MORPH,\n  TRACE_SILENT,\n  isTracing,\n  setTracing,\n};\n","// A domain, in this lib, is a set of numbers denoted by lo-hi range pairs (inclusive)\n// for memory and performance reasons fdq has three different representations for a domain;\n// - arrdom: an array with number pairs. mostly used by external apis because its easier to deal with. GC sensitive.\n// - numdom: a 31bit field where each bit represents the inclusion of a value of its index (0 through 30). 31st bit unused\n// - strdom: each value of an arrdom encoded as a double 16bit character. fixed range size (4 characters).\n\nimport {\n  NO_SUCH_VALUE,\n  NOT_FOUND,\n  ARR_RANGE_SIZE,\n  SMALL_MAX_NUM,\n  SOLVED_FLAG,\n  SUB,\n  SUP,\n} from '../constants';\n\nimport {\n  ASSERT,\n  ASSERT_ARRDOM,\n  ASSERT_BITDOM,\n  ASSERT_NUMDOM,\n  ASSERT_NORDOM,\n  ASSERT_SOLDOM,\n  ASSERT_STRDOM,\n} from '../assert';\n\n// CSIS form = Canonical Sorted Interval Sequence form.\n// Basically means the ranges in the domain are ordered\n// ascending and no ranges overlap. We call this \"simplified\"\n\n// const FIRST_RANGE = 0;\nconst STR_FIRST_RANGE_LO = 0; // First and second char of a string\nconst STR_FIRST_RANGE_HI = 2; // Third and fourth char of a string\nconst ARR_FIRST_RANGE_LO = 0;\nconst ARR_FIRST_RANGE_HI = 1;\n\n// Cache static Math functions\nconst MIN = Math.min;\nconst MAX = Math.max;\nconst FLOOR = Math.floor;\nconst CEIL = Math.ceil;\n\n// Size of values and ranges in a string domain\nconst STR_VALUE_SIZE = 2;\nconst STR_RANGE_SIZE = 4;\n\nconst EMPTY = 0;\nconst EMPTY_STR = '';\n\nconst DOM_ZERO = domain_createValue(0);\nconst DOM_BOOL = domain_createRange(0, 1);\n\n///**\n// * Append given range to the end of given domain. Does not\n// * check if the range belongs there! Dumbly appends.\n// *\n// * @param {$nordom} domain\n// * @param {number} lo\n// * @param {number} hi\n// * @returns {$domain}\n// */\n// function domain_appendRange(domain, lo, hi) {\n//  ASSERT_NORDOM(domain);\n//\n//  if (typeof domain === 'number') {\n//    // note: this function should not receive numdoms with a SOLVED_FLAG set\n//    // it is only used in temporary array cases, the flag must be set afterwards\n//    ASSERT(domain < SOLVED_FLAG, 'not expecting solved numdoms');\n//    if (hi <= SMALL_MAX_NUM) return domain_bit_addRange(domain, lo, hi);\n//    domain = domain_numToStr(domain);\n//  }\n//  return domain_str_addRange(domain, lo, hi);\n// }\n/**\n * Append given range to the end of given domain. Does not\n * check if the range belongs there! Dumbly appends.\n *\n * @param {$nordom} domain\n * @param {number} lo\n * @param {number} hi\n * @returns {$domain}\n */\nfunction domain_bit_addRange(domain, lo, hi) {\n  ASSERT_BITDOM(domain);\n  // What we do is:\n  // - create a 1\n  // - move the 1 to the left, `1+to-from` times\n  // - subtract 1 to get a series of `to-from` ones\n  // - shift those ones `from` times to the left\n  // - OR that result with the domain and return it\n\n  const range = ((1 << (1 + (hi | 0) - (lo | 0))) - 1) << lo;\n  return domain | range;\n}\n/**\n * Append given range to the end of given domain. Does not\n * check if the range belongs there! Dumbly appends.\n *\n * @param {$nordom} domain\n * @param {number} lo\n * @param {number} hi\n * @returns {$domain}\n */\n// function domain_str_addRange(domain, lo, hi) {\n//  ASSERT_STRDOM(domain);\n//  ASSERT(lo >= 0);\n//  ASSERT(hi <= SUP);\n//  ASSERT(lo <= hi);\n//\n//  return domain + domain_str_encodeRange(lo, hi);\n// }\n\n/**\n * returns whether domain covers given value\n *\n * @param {$nordom} domain\n * @param {number} value\n * @returns {boolean}\n */\nfunction domain_containsValue(domain, value) {\n  ASSERT_NORDOM(domain);\n\n  if (typeof domain === 'number')\n    return domain_num_containsValue(domain, value);\n  return domain_str_containsValue(domain, value);\n}\n\nfunction domain_num_containsValue(domain, value) {\n  ASSERT_NUMDOM(domain);\n\n  if (domain >= SOLVED_FLAG) return domain_sol_containsValue(domain, value);\n  return domain_bit_containsValue(domain, value);\n}\n\nfunction domain_sol_containsValue(domain, value) {\n  ASSERT_SOLDOM(domain);\n  ASSERT(typeof value === 'number', 'A_VALUE_SHOULD_BE_NUMBER');\n  ASSERT(value >= SUB);\n  ASSERT(value <= SUP);\n\n  return (domain ^ SOLVED_FLAG) === value;\n}\n\nfunction domain_bit_containsValue(domain, value) {\n  ASSERT_BITDOM(domain);\n  ASSERT(typeof value === 'number', 'A_VALUE_SHOULD_BE_NUMBER');\n  ASSERT(value >= SUB, 'OOB');\n  ASSERT(value <= SUP, 'OOB');\n\n  if (value < SUB || value > SMALL_MAX_NUM) return false;\n  return (domain & (1 << value)) !== 0;\n}\n\nfunction domain_str_containsValue(domain, value) {\n  ASSERT_STRDOM(domain);\n  ASSERT(typeof value === 'number', 'A_VALUE_SHOULD_BE_NUMBER');\n  ASSERT(value >= SUB, 'value must be >=SUB', value);\n  ASSERT(value <= SUP, 'value must be <=SUP', value);\n\n  return domain_str_rangeIndexOf(domain, value) !== NOT_FOUND;\n}\n\n/**\n * Return the range index in given domain that covers given\n * value, or if the domain does not cover it at all\n *\n * @param {$strdom} domain\n * @param {number} value\n * @returns {number} >=0 actual index on strdom or NOT_FOUND\n */\nfunction domain_str_rangeIndexOf(domain, value) {\n  ASSERT_STRDOM(domain);\n  ASSERT(domain !== '', 'NOT_EMPTY_STR');\n  ASSERT(typeof value === 'number', 'A_VALUE_SHOULD_BE_NUMBER');\n  ASSERT(value >= SUB);\n  ASSERT(value <= SUP);\n\n  const len = domain.length;\n\n  for (let index = 0; index < len; index += STR_RANGE_SIZE) {\n    const lo = domain_str_decodeValue(domain, index);\n    if (lo <= value) {\n      const hi = domain_str_decodeValue(domain, index + STR_VALUE_SIZE);\n      if (hi >= value) {\n        // Value is lo<=value<=hi\n        return index;\n      }\n    } else {\n      // Value is between previous range and this one, aka: not found.\n      break;\n    }\n  }\n\n  return NOT_FOUND;\n}\n\n/**\n * Check if given domain is solved. If so, return the value\n * to which it was solved. Otherwise return NO_SUCH_VALUE.\n *\n * @param {$nordom} domain\n * @returns {number}\n */\nfunction domain_getValue(domain) {\n  ASSERT_NORDOM(domain);\n  // TODO: in a sound system we'd only have to check for soldoms...\n\n  if (typeof domain === 'number') return domain_num_getValue(domain);\n  return domain_str_getValue(domain);\n}\n\nfunction domain_num_getValue(domain) {\n  ASSERT_NUMDOM(domain);\n\n  if (domain >= SOLVED_FLAG) return domain_sol_getValue(domain);\n  return domain_bit_getValue(domain);\n}\n\nfunction domain_sol_getValue(domain) {\n  ASSERT_SOLDOM(domain);\n\n  return domain ^ SOLVED_FLAG;\n}\n\nfunction domain_bit_getValue(domain) {\n  ASSERT_BITDOM(domain);\n\n  const lo = domain_bit_min(domain);\n  return domain === 1 << lo ? lo : NO_SUCH_VALUE;\n}\n\nfunction domain_str_getValue(domain) {\n  ASSERT_STRDOM(domain);\n\n  if (domain.length !== STR_RANGE_SIZE) return NO_SUCH_VALUE;\n  const lo = domain_str_decodeValue(domain, STR_FIRST_RANGE_LO);\n  const hi = domain_str_decodeValue(domain, STR_FIRST_RANGE_HI);\n  if (lo === hi) return lo;\n  return NO_SUCH_VALUE;\n}\n\n/**\n * @param {$strdom} domain\n * @param {number} index\n * @returns {number}\n */\nfunction domain_str_decodeValue(domain, index) {\n  ASSERT_STRDOM(domain);\n\n  return (domain.charCodeAt(index) << 16) | domain.charCodeAt(index + 1);\n}\n\n/**\n * @param {number} value\n * @returns {string} not a $strdom but half of one\n */\nfunction domain_str_encodeValue(value) {\n  return String.fromCharCode((value >>> 16) & 0xffff, value & 0xffff);\n}\n\n/**\n * @param {number} lo\n * @param {number} hi\n * @returns {$strdom} One range is still a valid domain\n */\nfunction domain_str_encodeRange(lo, hi) {\n  return String.fromCharCode(\n    (lo >>> 16) & 0xffff,\n    lo & 0xffff,\n    (hi >>> 16) & 0xffff,\n    hi & 0xffff\n  );\n}\n\n/**\n * External API only. Always returns an arrdom.\n *\n * @param {number[]} list\n * @returns {$arrdom}\n */\nfunction domain_fromListToArrdom(list) {\n  if (list.length === 0) return [];\n  list = list.slice(0);\n  list.sort((a, b) => a - b); // Note: default sort is lexicographic!\n\n  const arrdom = [];\n  let hi;\n  let lo;\n  for (let index = 0; index < list.length; index++) {\n    const value = list[index];\n    ASSERT(value >= SUB, 'A_OOB_INDICATES_BUG');\n    ASSERT(value <= SUP, 'A_OOB_INDICATES_BUG');\n    if (index === 0) {\n      lo = value;\n      hi = value;\n    } else {\n      ASSERT(value >= hi, 'LIST_SHOULD_BE_ORDERED_BY_NOW'); // Imo it should not even contain dupe elements... but that may happen anyways\n      if (value > hi + 1) {\n        arrdom.push(lo, hi);\n        lo = value;\n      }\n\n      hi = value;\n    }\n  }\n\n  arrdom.push(lo, hi);\n\n  ASSERT_ARRDOM(arrdom);\n  return arrdom;\n}\n\n/**\n * Domain to list of possible values\n *\n * @param {$nordom} domain\n * @returns {number[]}\n *\n * @nosideffects\n */\nfunction domain_toList(domain) {\n  ASSERT_NORDOM(domain);\n\n  if (typeof domain === 'number') return domain_num_toList(domain);\n  return domain_str_toList(domain);\n}\n\nfunction domain_num_toList(domain) {\n  ASSERT_NUMDOM(domain);\n\n  if (domain >= SOLVED_FLAG) return domain_sol_toList(domain);\n  return domain_bit_toList(domain);\n}\n\nfunction domain_sol_toList(domain) {\n  ASSERT_SOLDOM(domain);\n\n  return [domain ^ SOLVED_FLAG];\n}\n\nfunction domain_bit_toList(domain) {\n  ASSERT_BITDOM(domain);\n\n  const list = [];\n  for (let i = 0; i < SMALL_MAX_NUM; ++i) {\n    if ((domain & ((1 << i) >>> 0)) > 0) list.push(i);\n  }\n\n  return list;\n}\n\nfunction domain_str_toList(domain) {\n  ASSERT_STRDOM(domain);\n\n  const list = [];\n  for (let i = 0, len = domain.length; i < len; i += STR_RANGE_SIZE) {\n    for (\n      let n = domain_str_decodeValue(domain, i),\n        m = domain_str_decodeValue(domain, i + STR_VALUE_SIZE);\n      n <= m;\n      ++n\n    ) {\n      list.push(n);\n    }\n  }\n\n  return list;\n}\n\n/**\n * @param {$nordom} domain\n * @param {number[]} list\n * @returns {number} Can return NO_SUCH_VALUE\n */\nfunction domain_getFirstIntersectingValue(domain, list) {\n  ASSERT_NORDOM(domain);\n\n  if (typeof domain === 'number')\n    return domain_num_getFirstIntersectingValue(domain, list);\n  return domain_str_getFirstIntersectingValue(domain, list);\n}\n\nfunction domain_num_getFirstIntersectingValue(domain, list) {\n  ASSERT_NUMDOM(domain);\n\n  if (domain >= SOLVED_FLAG)\n    return domain_sol_getFirstIntersectingValue(domain, list);\n  return domain_bit_getFirstIntersectingValue(domain, list);\n}\n\nfunction domain_sol_getFirstIntersectingValue(domain, list) {\n  ASSERT_SOLDOM(domain);\n  ASSERT(list && Array.isArray(list), 'A_EXPECTING_LIST');\n\n  const solvedValue = domain ^ SOLVED_FLAG;\n  if (list.indexOf(solvedValue) >= 0) return solvedValue;\n  return NO_SUCH_VALUE;\n}\n\nfunction domain_bit_getFirstIntersectingValue(domain, list) {\n  ASSERT_BITDOM(domain);\n  ASSERT(list && Array.isArray(list), 'A_EXPECTING_LIST');\n\n  for (let i = 0; i < list.length; ++i) {\n    const value = list[i];\n    ASSERT(value >= SUB && value <= SUP, 'A_OOB_INDICATES_BUG'); // Internally all domains elements should be sound; SUB>=n>=SUP\n    // 1<<100 = 16 and large numbers are valid here so do check\n    if (value <= SMALL_MAX_NUM && (domain & (1 << value)) > 0) return value;\n  }\n\n  return NO_SUCH_VALUE;\n}\n\nfunction domain_str_getFirstIntersectingValue(domain, list) {\n  ASSERT_STRDOM(domain);\n  ASSERT(list && Array.isArray(list), 'A_EXPECTING_LIST');\n\n  for (let i = 0; i < list.length; i++) {\n    const value = list[i];\n    ASSERT(value >= SUB && value <= SUP, 'A_OOB_INDICATES_BUG'); // Internally all domains elements should be sound; SUB>=n>=SUP\n    if (domain_str_containsValue(domain, value)) {\n      return value;\n    }\n  }\n\n  return NO_SUCH_VALUE;\n}\n\n/**\n * All ranges will be ordered ascending and overlapping ranges are merged\n * This function first checks whether simplification is needed at all\n * Should normalize all return values.\n *\n * @param {$strdom|string} domain\n * @returns {$strdom} ironically, not optimized to a number if possible\n */\nfunction domain_str_simplify(domain) {\n  ASSERT_STRDOM(domain);\n\n  if (!domain) return EMPTY; // Keep return type consistent, dont return EMPTY\n  if (domain.length === STR_RANGE_SIZE) return domain_toSmallest(domain);\n\n  // Order ranges, then merge overlapping ranges (TODO: can we squash this step together?)\n  domain = _domain_str_quickSortRanges(domain);\n  domain = _domain_str_mergeOverlappingRanges(domain);\n\n  return domain_toSmallest(domain);\n}\n\n/**\n * Sort all ranges in this pseudo-strdom from lo to hi. Domain\n * may already be csis but we're not sure. This function call\n * is part of the process of ensuring that.\n *\n * @param {$strdom|string} domain MAY not be CSIS yet (that's probably why this function is called in the first place)\n * @returns {$strdom|string} ranges in this string will be ordered but may still overlap\n */\nfunction _domain_str_quickSortRanges(domain) {\n  ASSERT_STRDOM(domain);\n\n  if (!domain) return EMPTY_STR; // Keep return type consistent, dont return EMPTY\n\n  const len = domain.length;\n  if (len <= STR_RANGE_SIZE) return domain;\n\n  // TODO: right now we convert to actual values and concat with \"direct\" string access. would it be faster to use slices? and would it be faster to do string comparisons with the slices and no decoding?\n\n  const pivotIndex = 0; // TODO: i think we'd be better off with a different pivot? middle probably performs better\n  const pivotLo = domain_str_decodeValue(domain, pivotIndex);\n  const pivotHi = domain_str_decodeValue(domain, pivotIndex + STR_VALUE_SIZE);\n\n  let left = EMPTY_STR;\n  let right = EMPTY_STR;\n\n  for (let i = STR_RANGE_SIZE; i < len; i += STR_RANGE_SIZE) {\n    const lo = domain_str_decodeValue(domain, i);\n\n    // TODO: if we change assumptions elsewhere we could drop the `hi` stuff from this function altogether\n    if (\n      lo < pivotLo ||\n      (lo === pivotLo &&\n        domain_str_decodeValue(domain, i + STR_VALUE_SIZE) < pivotHi)\n    ) {\n      left += domain[i] + domain[i + 1] + domain[i + 2] + domain[i + 3];\n    } else {\n      right += domain[i] + domain[i + 1] + domain[i + 2] + domain[i + 3];\n    }\n  }\n\n  return (\n    String(_domain_str_quickSortRanges(left)) + // Sort left part, without pivot\n    domain[pivotIndex] + // Include pivot (4 chars)\n    domain[pivotIndex + 1] +\n    domain[pivotIndex + STR_VALUE_SIZE] +\n    domain[pivotIndex + STR_VALUE_SIZE + 1] +\n    _domain_str_quickSortRanges(right) // Sort right part, without pivot\n  );\n}\n\n/**\n * @param {$strdom|string} domain May already be csis but at least all ranges should be ordered and are lo<=hi\n * @returns {$strdom}\n */\nfunction _domain_str_mergeOverlappingRanges(domain) {\n  ASSERT_STRDOM(domain);\n  if (!domain) return EMPTY_STR; // Prefer strings for return type consistency\n\n  // assumes domain is sorted\n  // assumes all ranges are \"sound\" (lo<=hi)\n\n  const len = domain.length;\n  if (len === STR_RANGE_SIZE) return domain;\n\n  let newDomain = domain[STR_FIRST_RANGE_LO] + domain[STR_FIRST_RANGE_LO + 1]; // Just copy the first two characters...\n  let lasthi = domain_str_decodeValue(domain, STR_FIRST_RANGE_HI);\n  let lasthindex = STR_FIRST_RANGE_HI;\n\n  for (let i = STR_RANGE_SIZE; i < len; i += STR_RANGE_SIZE) {\n    const lo = domain_str_decodeValue(domain, i);\n    const hi = domain_str_decodeValue(domain, i + STR_VALUE_SIZE);\n    ASSERT(lo <= hi, 'ranges should be ascending');\n\n    // Either:\n    // - lo <= lasthi, hi <= lasthi: last range consumes current range (drop it)\n    // - lo <= lasthi+1: replace lasthi, last range is extended by current range\n    // - lo >= lasthi+2: flush lasthi, replace lastlo and lasthi, current range becomes last range\n\n    // if (lo <= lasthi && hi <= lasthi) {}\n    // else\n    if (lo <= lasthi + 1) {\n      if (hi > lasthi) {\n        lasthi = hi;\n        lasthindex = i + STR_VALUE_SIZE;\n      }\n    } else {\n      ASSERT(lo >= lasthi + 2, 'should be this now');\n      newDomain +=\n        domain[lasthindex] + domain[lasthindex + 1] + domain[i] + domain[i + 1];\n      lasthi = hi;\n      lasthindex = i + STR_VALUE_SIZE;\n    }\n  }\n\n  return newDomain + domain[lasthindex] + domain[lasthindex + 1];\n}\n\n/**\n * Intersect two $domains.\n * Intersection means the result only contains the values\n * that are contained in BOTH domains.\n *\n * @param {$nordom} domain1\n * @param {$nordom} domain2\n * @returns {$nordom}\n */\nfunction domain_intersection(domain1, domain2) {\n  ASSERT_NORDOM(domain1);\n  ASSERT_NORDOM(domain2);\n\n  if (domain1 === domain2) return domain1;\n  const isNum1 = typeof domain1 === 'number';\n  const isNum2 = typeof domain2 === 'number';\n\n  if (isNum1 && isNum2) return domain_numnum_intersection(domain1, domain2);\n  if (isNum1) return domain_numstr_intersection(domain1, domain2);\n  if (isNum2) return domain_numstr_intersection(domain2, domain1); // Swapped!\n  return domain_strstr_intersection(domain1, domain2);\n}\n\nfunction domain_numnum_intersection(domain1, domain2) {\n  ASSERT_NUMDOM(domain1);\n  ASSERT_NUMDOM(domain2);\n\n  const sol1 = domain1 >= SOLVED_FLAG;\n  const sol2 = domain2 >= SOLVED_FLAG;\n  if (sol1) {\n    if (sol2) return domain_solsol_intersect(domain1, domain2);\n    return domain_solbit_intersect(domain1, domain2);\n  }\n\n  if (sol2) return domain_solbit_intersect(domain2, domain1);\n\n  return domain_bitbit_intersect(domain1, domain2);\n}\n\nfunction domain_solbit_intersect(soldom, bitdom) {\n  ASSERT_SOLDOM(soldom);\n  ASSERT_BITDOM(bitdom);\n\n  const solvedValue = soldom ^ SOLVED_FLAG;\n  if (solvedValue <= SMALL_MAX_NUM && bitdom & (1 << solvedValue))\n    return soldom;\n  return EMPTY;\n}\n\nfunction domain_solsol_intersect(domain1, domain2) {\n  ASSERT_SOLDOM(domain1);\n  ASSERT_SOLDOM(domain2);\n\n  if (domain1 === domain2) return domain1;\n  return EMPTY;\n}\n\nfunction domain_bitbit_intersect(domain1, domain2) {\n  ASSERT_BITDOM(domain1);\n  ASSERT_BITDOM(domain2);\n\n  return domain_bitToSmallest(domain1 & domain2);\n}\n\nfunction domain_numstr_intersection(numdom, strdom) {\n  ASSERT_NUMDOM(numdom);\n  ASSERT_STRDOM(strdom);\n\n  if (numdom >= SOLVED_FLAG) return domain_solstr_intersect(numdom, strdom);\n  return domain_bitstr_intersect(numdom, strdom);\n}\n\nfunction domain_solstr_intersect(soldom, strdom) {\n  ASSERT_SOLDOM(soldom);\n  ASSERT_STRDOM(strdom);\n\n  const solvedValue = soldom ^ SOLVED_FLAG;\n\n  for (let i = 0, len = strdom.length; i < len; i += STR_RANGE_SIZE) {\n    const lo = domain_str_decodeValue(strdom, i);\n    const hi = domain_str_decodeValue(strdom, i + STR_VALUE_SIZE);\n    // Once a range is found beyond the solved value we can never find solved value in domain_str\n    if (solvedValue < lo) break;\n    // When lo<=value<=hi the intersection is non-empty. return the solved domain.\n    if (solvedValue <= hi) return soldom;\n  }\n\n  return EMPTY;\n}\n\nfunction domain_bitstr_intersect(bitdom, strdom) {\n  ASSERT_BITDOM(bitdom);\n  ASSERT_STRDOM(strdom);\n\n  // TODO: intersect in a \"zipper\" O(max(n,m)) algorithm instead of O(n*m). see _domain_strstr_intersection\n  let domain = EMPTY;\n  for (let i = 0, len = strdom.length; i < len; i += STR_RANGE_SIZE) {\n    const lo = domain_str_decodeValue(strdom, i);\n    if (lo > SMALL_MAX_NUM) break;\n    const hi = domain_str_decodeValue(strdom, i + STR_VALUE_SIZE);\n\n    for (let j = lo, m = MIN(SMALL_MAX_NUM, hi); j <= m; ++j) {\n      const flag = 1 << j;\n      if (bitdom & flag) domain |= flag; // Could be: domain |= domain1 & NUMBER[j]; but this reads better?\n    }\n  }\n\n  return domain_bitToSmallest(domain);\n}\n\nfunction domain_strstr_intersection(domain1, domain2) {\n  ASSERT_STRDOM(domain1);\n  ASSERT_STRDOM(domain2);\n\n  const len1 = domain1.length;\n  const len2 = domain2.length;\n\n  if ((len1 | len2) === 0) return EMPTY;\n\n  let newDomain = EMPTY_STR;\n\n  let index1 = 0;\n  let index2 = 0;\n\n  let lo1 = domain_str_decodeValue(domain1, STR_FIRST_RANGE_LO);\n  let hi1 = domain_str_decodeValue(domain1, STR_FIRST_RANGE_HI);\n  let lo2 = domain_str_decodeValue(domain2, STR_FIRST_RANGE_LO);\n  let hi2 = domain_str_decodeValue(domain2, STR_FIRST_RANGE_HI);\n\n  while (true) {\n    if (hi1 < lo2) {\n      index1 += STR_RANGE_SIZE;\n      if (index1 >= len1) break;\n      lo1 = domain_str_decodeValue(domain1, index1);\n      hi1 = domain_str_decodeValue(domain1, index1 + STR_VALUE_SIZE);\n    } else if (hi2 < lo1) {\n      index2 += STR_RANGE_SIZE;\n      if (index2 >= len2) break;\n      lo2 = domain_str_decodeValue(domain2, index2);\n      hi2 = domain_str_decodeValue(domain2, index2 + STR_VALUE_SIZE);\n    } else {\n      ASSERT(\n        (lo1 <= lo2 && lo2 <= hi1) || (lo2 <= lo1 && lo1 <= hi2),\n        '_domain_strstr_intersection: both ranges must overlap at least for some element because neither ends before the other [' +\n          lo1 +\n          ',' +\n          hi1 +\n          ' - ' +\n          lo2 +\n          ',' +\n          hi2 +\n          ']'\n      );\n\n      let mh = MIN(hi1, hi2);\n      newDomain += domain_str_encodeRange(MAX(lo1, lo2), mh);\n\n      // Put all ranges after the one we just added...\n      mh += 2; // Last added range + 1 position gap\n      lo1 = lo2 = mh;\n      ASSERT(\n        hi1 < mh || hi2 < mh,\n        'at least one range should be moved forward now'\n      );\n      if (hi1 < mh) {\n        index1 += STR_RANGE_SIZE;\n        if (index1 >= len1) break;\n        lo1 = domain_str_decodeValue(domain1, index1);\n        hi1 = domain_str_decodeValue(domain1, index1 + STR_VALUE_SIZE);\n      }\n\n      if (hi2 < mh) {\n        index2 += STR_RANGE_SIZE;\n        if (index2 >= len2) break;\n        lo2 = domain_str_decodeValue(domain2, index2);\n        hi2 = domain_str_decodeValue(domain2, index2 + STR_VALUE_SIZE);\n      }\n    }\n  }\n\n  if (newDomain === EMPTY_STR) return EMPTY;\n  return domain_toSmallest(newDomain);\n}\n\n/**\n * Check if domain contains value, if so, return a domain with\n * just given value. Otherwise return the empty domain.\n *\n * @param {$nordom} domain\n * @param {number} value\n * @returns {$nordom}\n */\nfunction domain_intersectionValue(domain, value) {\n  ASSERT_NORDOM(domain);\n  ASSERT(value >= SUB && value <= SUP, 'Expecting valid value');\n\n  if (domain_containsValue(domain, value)) return domain_createValue(value);\n  return domain_createEmpty();\n}\n\n/**\n * Return a simple string showing the given domain in array\n * form and the representation type that was passed on.\n *\n * @param {$domain} domain\n * @returns {string}\n */\nfunction domain__debug(domain) {\n  if (typeof domain === 'number') {\n    if (domain >= SOLVED_FLAG)\n      return (\n        'soldom([' +\n        (domain ^ SOLVED_FLAG) +\n        ',' +\n        (domain ^ SOLVED_FLAG) +\n        '])'\n      );\n    return 'numdom([' + domain_numToArr(domain) + '])';\n  }\n\n  if (typeof domain === 'string')\n    return 'strdom([' + domain_strToArr(domain) + '])';\n  if (Array.isArray(domain)) return 'arrdom([' + domain + '])';\n  return '???dom(' + domain + ')';\n}\n\n/**\n * The idea behind this function - which is primarily\n * intended for domain_plus and domain_minus and probably applies\n * to nothing else - is that when adding two intervals,\n * both intervals expand by the other's amount. This means\n * that when given two segmented domains, each continuous\n * range expands by at least the interval of the smallest\n * range of the other segmented domain. When such an expansion\n * occurs, any gaps between subdomains that are <= the smallest\n * range's interval width get filled up, which we can exploit\n * to reduce the number of segments in a domain. Reducing the\n * number of domain segments helps reduce the N^2 complexity of\n * the subsequent domain consistent interval addition method.\n *\n * @param {$strdom} domain1\n * @param {$strdom} domain2\n * @returns {$strdom[]} NOT smallest! call sites depend on strdom, and they will take care of normalization\n */\nfunction domain_str_closeGaps(domain1, domain2) {\n  ASSERT_STRDOM(domain1);\n  ASSERT_STRDOM(domain2);\n\n  if (domain1 && domain2) {\n    let change;\n    do {\n      change = 0;\n\n      if (domain1.length > STR_RANGE_SIZE) {\n        const smallestRangeSize = domain_str_smallestRangeSize(domain2);\n        const domain = _domain_str_closeGaps(domain1, smallestRangeSize);\n        change += domain1.length - domain.length;\n        domain1 = domain;\n      }\n\n      if (domain2.length > STR_RANGE_SIZE) {\n        const smallestRangeSize = domain_str_smallestRangeSize(domain1);\n        const domain = _domain_str_closeGaps(domain2, smallestRangeSize);\n        change += domain2.length - domain.length;\n        domain2 = domain;\n      }\n    } while (change !== 0);\n  }\n\n  // TODO: we could return a concatted string and prefix the split, instead of this temporary array...\n  return [domain1, domain2];\n}\n\n/**\n * Closes all the gaps between the intervals according to\n * the given gap value. All gaps less than this gap are closed.\n * Domain is not harmed\n *\n * @param {$strdom} domain\n * @param {number} gap\n * @returns {$strdom} (min/max won't be eliminated and input should be a \"large\" domain)\n */\nfunction _domain_str_closeGaps(domain, gap) {\n  ASSERT_STRDOM(domain);\n\n  let newDomain = domain[STR_FIRST_RANGE_LO] + domain[STR_FIRST_RANGE_LO + 1];\n  let lasthi = domain_str_decodeValue(domain, STR_FIRST_RANGE_HI);\n  let lasthindex = STR_FIRST_RANGE_HI;\n\n  for (\n    let i = STR_RANGE_SIZE, len = domain.length;\n    i < len;\n    i += STR_RANGE_SIZE\n  ) {\n    const lo = domain_str_decodeValue(domain, i);\n    const hi = domain_str_decodeValue(domain, i + STR_VALUE_SIZE);\n\n    if (lo - lasthi > gap) {\n      newDomain +=\n        domain[lasthindex] + domain[lasthindex + 1] + domain[i] + domain[i + 1];\n    }\n\n    lasthi = hi;\n    lasthindex = i + STR_VALUE_SIZE;\n  }\n\n  newDomain += domain[lasthindex] + domain[lasthindex + 1];\n\n  return newDomain;\n}\n\n/**\n * @param {$strdom} domain\n * @returns {number}\n */\nfunction domain_str_smallestRangeSize(domain) {\n  ASSERT_STRDOM(domain);\n\n  let min_width = SUP;\n\n  for (let i = 0, len = domain.length; i < len; i += STR_RANGE_SIZE) {\n    const lo = domain_str_decodeValue(domain, i);\n    const hi = domain_str_decodeValue(domain, i + STR_VALUE_SIZE);\n    const width = 1 + hi - lo;\n    if (width < min_width) {\n      min_width = width;\n    }\n  }\n\n  return min_width;\n}\n\n/**\n * Note that this one isn't domain consistent.\n *\n * @param {$nordom} domain1\n * @param {$nordom} domain2\n * @returns {$domain}\n */\nfunction domain_mul(domain1, domain2) {\n  ASSERT_NORDOM(domain1);\n  ASSERT_NORDOM(domain2);\n\n  // TOFIX: quick shortcut for solved domains\n\n  // for simplicity sake, convert them back to arrays\n  if (typeof domain1 === 'number') domain1 = domain_numToStr(domain1);\n  if (typeof domain2 === 'number') domain2 = domain_numToStr(domain2);\n\n  // TODO domain_mulNum\n  return domain_strstr_mul(domain1, domain2);\n}\n\nfunction domain_strstr_mul(domain1, domain2) {\n  ASSERT_STRDOM(domain1);\n  ASSERT_STRDOM(domain2);\n\n  let result = EMPTY_STR;\n  for (let i = 0, leni = domain1.length; i < leni; i += STR_RANGE_SIZE) {\n    const lo = domain_str_decodeValue(domain1, i);\n    const hi = domain_str_decodeValue(domain1, i + STR_VALUE_SIZE);\n\n    result += _domain_str_mulByRange(domain2, lo, hi);\n  }\n\n  // TODO: is it worth doing this step immediately?\n  return domain_str_simplify(result);\n}\n\n/**\n * Multiply a domain by given range\n *\n * @param {$strdom} strdom\n * @param {number} lo\n * @param {number} hi\n * @returns {$strdom} NOT normalized\n */\nfunction _domain_str_mulByRange(strdom, lo, hi) {\n  ASSERT_STRDOM(strdom, false, domain__debug);\n  ASSERT(typeof lo === 'number', 'lo should be number');\n  ASSERT(typeof hi === 'number', 'hi should be number');\n\n  let result = EMPTY_STR;\n  for (let j = 0, len = strdom.length; j < len; j += STR_RANGE_SIZE) {\n    const loj = domain_str_decodeValue(strdom, j);\n    const hij = domain_str_decodeValue(strdom, j + STR_VALUE_SIZE);\n\n    result += domain_str_encodeRange(MIN(SUP, lo * loj), MIN(SUP, hi * hij));\n  }\n\n  return result;\n}\n\n/**\n * Multiply given domain by a single value\n * [1, 10] * 5 = [5, 50]\n *\n * @param {$nordom} domain\n * @param {number} value\n * @returns {$nordom}\n */\nfunction domain_mulByValue(domain, value) {\n  ASSERT_NORDOM(domain, false, domain__debug);\n  ASSERT(typeof value === 'number', 'value should be number');\n  ASSERT(value >= 0, 'cannot use negative numbers');\n  ASSERT(arguments.length === 2, 'not expecting a range');\n\n  if (typeof domain === 'number') domain = domain_numToStr(domain);\n  domain = _domain_str_mulByRange(domain, value, value);\n\n  return domain_str_simplify(domain);\n}\n\n/**\n * Divide one range by another\n * Result has any integer values that are equal or between\n * the real results. This means fractions are floored/ceiled.\n * This is an expensive operation.\n * Zero is a special case.\n *\n * Does not harm input domains\n *\n * @param {$nordom} domain1\n * @param {$nordom} domain2\n * @param {boolean} [floorFractions=true] Include the floored lo of the resulting ranges?\n *         For example, <5,5>/<2,2> is <2.5,2.5>. If this flag is true, it will include\n *         <2,2>, otherwise it will not include anything for that division.\n * @returns {$nordom}\n */\nfunction domain_divby(domain1, domain2, floorFractions = true) {\n  ASSERT_NORDOM(domain1);\n  ASSERT_NORDOM(domain2);\n\n  // TOFIX: add quick shortcut for solved domains\n\n  // for simplicity sake, convert them back to arrays\n  if (typeof domain1 === 'number') domain1 = domain_numToStr(domain1);\n  if (typeof domain2 === 'number') domain2 = domain_numToStr(domain2);\n\n  // TODO: domain_divByNum\n  return domain_strstr_divby(domain1, domain2, floorFractions);\n}\n\nfunction domain_strstr_divby(domain1, domain2, floorFractions = true) {\n  ASSERT_STRDOM(domain1);\n  ASSERT_STRDOM(domain2);\n\n  let result = EMPTY_STR;\n  for (let i = 0, leni = domain2.length; i < leni; i += STR_RANGE_SIZE) {\n    const lo = domain_str_decodeValue(domain2, i);\n    const hi = domain_str_decodeValue(domain2, i + STR_VALUE_SIZE);\n\n    result += _domain_str_divbyRange(domain1, lo, hi, floorFractions);\n  }\n\n  return domain_str_simplify(result);\n}\n\nfunction _domain_str_divbyRange(strdom, divisorLo, divisorHi, floorFractions) {\n  // Division: Dividend / Divisor = Quotient\n  ASSERT_STRDOM(strdom);\n  ASSERT(typeof divisorLo === 'number', 'lo should be a number');\n  ASSERT(typeof divisorHi === 'number', 'hi should be a number');\n  ASSERT(divisorLo >= 0 && divisorHi >= 0, 'lo/hi cannot be negative');\n\n  let result = EMPTY_STR;\n  for (let j = 0, lenj = strdom.length; j < lenj; j += STR_RANGE_SIZE) {\n    const dividendLo = domain_str_decodeValue(strdom, j);\n    const dividendHi = domain_str_decodeValue(strdom, j + STR_VALUE_SIZE);\n\n    // Cannot /0\n    // we ignore it right now. should we...\n    // - add a 0 or SUB or SUP for it\n    // - throw an error / issue a warning for it\n    if (divisorHi > 0) {\n      const quotientLo = dividendLo / divisorHi;\n      const quotientHi = divisorLo > 0 ? dividendHi / divisorLo : SUP;\n\n      // We cant use fractions, so we'll only include any values in the\n      // resulting domains that are _above_ the lo and _below_ the hi.\n      const left = CEIL(quotientLo);\n      const right = FLOOR(quotientHi);\n\n      // If the fraction is within the same integer this could result in\n      // lo>hi so we must prevent this case\n      if (left <= right) {\n        result += domain_str_encodeRange(left, right);\n      } else {\n        ASSERT(\n          FLOOR(quotientLo) === FLOOR(quotientHi),\n          'left>right when fraction is in same int, which can happen',\n          quotientLo,\n          quotientHi\n        );\n        if (floorFractions) {\n          // Only use the floored value\n          // note: this is a choice. not both floor/ceil because then 5/2=2.5 becomes [2,3]. should be [2,2] or [3,3]\n          result += domain_str_encodeRange(right, right);\n        }\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction domain_divByValue(domain, value) {\n  ASSERT_NORDOM(domain, false, domain__debug);\n  ASSERT(typeof value === 'number', 'value should be number');\n  ASSERT(value >= 0, 'cannot use negative numbers');\n  ASSERT(arguments.length === 2, 'not expecting a range');\n\n  if (typeof domain === 'number') domain = domain_numToStr(domain);\n  const domain2 = _domain_str_divbyRange(domain, value, value);\n\n  return domain_str_simplify(domain2);\n}\n\n/**\n * Do the opposite of a mul. This is _like_ a div but there\n * are special cases for zeroes and fractions:\n * - x * y = 0\n *   - x / 0 = y (not infinity)\n *   - y / 0 = x (not infinity)\n * - 2 * x = [2, 3]\n *   - 2 / [1, 3] = x (integer division so x=1)\n *   - x / [1, 3] = 2\n *\n * @param {$nordom} domain1\n * @param {$nordom} domain2\n * @returns {$nordom}\n */\nfunction domain_invMul(domain1, domain2) {\n  ASSERT_NORDOM(domain1);\n  ASSERT_NORDOM(domain2);\n\n  // TOFIX: add quick shortcut for solved domains\n\n  // if (domain_isZero(domain2)) return domain1;\n  // for simplicity sake, convert them back to arrays\n  if (typeof domain1 === 'number') domain1 = domain_numToStr(domain1);\n  if (typeof domain2 === 'number') domain2 = domain_numToStr(domain2);\n\n  // TODO: domain_divByNum\n  return domain_strstr_invMul(domain1, domain2);\n}\n\nfunction domain_strstr_invMul(domain1, domain2) {\n  ASSERT_STRDOM(domain1);\n  ASSERT_STRDOM(domain2);\n\n  let result = EMPTY_STR;\n  for (let i = 0, len = domain2.length; i < len; i += STR_RANGE_SIZE) {\n    const lo = domain_str_decodeValue(domain2, i);\n    const hi = domain_str_decodeValue(domain2, i + STR_VALUE_SIZE);\n\n    result += _domain_str_invMulRange(domain1, lo, hi);\n  }\n\n  return domain_str_simplify(result);\n}\n\nfunction _domain_str_invMulRange(domain, divisorLo, divisorHi) {\n  // Note: act like div but do exact opposite of mul regardless\n  // all we worry about is the zero since input is >=0 and finite\n  ASSERT_STRDOM(domain);\n\n  let result = EMPTY_STR;\n  for (let i = 0, len = domain.length; i < len; i += STR_RANGE_SIZE) {\n    const dividendLo = domain_str_decodeValue(domain, i);\n    const dividendHi = domain_str_decodeValue(domain, i + STR_VALUE_SIZE);\n\n    const quotientLo = divisorHi ? dividendLo / divisorHi : SUB; // Use SUB if /0\n    const quotientHi = divisorLo ? dividendHi / divisorLo : SUP; // Use SUP if /0\n\n    // only care about the integers within the division range\n    const lo = CEIL(quotientLo);\n    const hi = FLOOR(quotientHi);\n    // If the lo hi quotients are inside the same integer, the result is empty\n    if (lo <= hi) {\n      result += domain_str_encodeRange(lo, hi);\n    }\n  }\n\n  return result;\n}\n\nfunction domain_invMulValue(domain, value) {\n  ASSERT_NORDOM(domain, false, domain__debug);\n  ASSERT(typeof value === 'number', 'value should be number');\n  ASSERT(value >= 0, 'cannot use negative numbers');\n  ASSERT(arguments.length === 2, 'not expecting a range');\n\n  if (typeof domain === 'number') domain = domain_numToStr(domain);\n  const domain2 = _domain_str_invMulRange(domain, value, value);\n\n  return domain_str_simplify(domain2);\n}\n\n/**\n * Return the number of elements this domain covers\n *\n * @param {$nordom} domain\n * @returns {number}\n */\nfunction domain_size(domain) {\n  ASSERT_NORDOM(domain);\n\n  if (typeof domain === 'number') return domain_num_size(domain);\n  return domain_str_size(domain);\n}\n\nfunction domain_num_size(domain) {\n  ASSERT_NUMDOM(domain);\n\n  if (domain >= SOLVED_FLAG) return 1;\n  return domain_bit_size(domain);\n}\n\nconst { _domain_bit_size } = (function() {\n  //'use asm';\n\n  function _domain_bit_size(domain) {\n    domain = domain | 0;\n\n    // Hot paths; binary\n    // the empty domain is \"free\"\n    switch (domain | 0) {\n      case 0:\n        return 0; // Empty domain\n      case 1:\n        return 1;\n      case 2:\n        return 1;\n      case 3:\n        return 2;\n      default:\n        break;\n    }\n\n    // 32-bit popcount (count of set bits) using the SWAR algorithm.\n    // See stackoverflow.com/a/109025\n    domain = (domain - ((domain >> 1) & 0x55555555)) | 0;\n    domain = ((domain & 0x33333333) + ((domain >> 2) & 0x33333333)) | 0;\n    domain = ((domain + (domain >> 4)) & 0x0f0f0f0f) | 0;\n    return ((domain << 24) + (domain << 16) + (domain << 8) + domain) >> 24 | 0;\n  }\n\n  return { _domain_bit_size };\n})();\n\nfunction domain_bit_size(domain) {\n  ASSERT_BITDOM(domain);\n\n  return _domain_bit_size(domain) | 0;\n}\n\nfunction domain_str_size(domain) {\n  ASSERT_STRDOM(domain);\n  ASSERT(domain && domain.length > 0, 'A_EXPECTING_NON_EMPTY_STRDOM');\n\n  let count = 0;\n\n  for (let i = 0, len = domain.length; i < len; i += STR_RANGE_SIZE) {\n    // TODO: add test to confirm this still works fine if SUB is negative\n    count +=\n      1 +\n      domain_str_decodeValue(domain, i + STR_VALUE_SIZE) -\n      domain_str_decodeValue(domain, i);\n  }\n\n  return count;\n}\n\n/**\n * Get the middle element of all elements in domain.\n * Not hi-lo/2 but the (size/2)th element.\n * For domains with an even number of elements it\n * will take the first value _above_ the middle,\n * in other words; index=ceil(count/2).\n *\n * @param {$nordom} domain\n * @returns {number} can return\n */\nfunction domain_middleElement(domain) {\n  ASSERT_NORDOM(domain);\n\n  if (typeof domain === 'number') {\n    if (domain >= SOLVED_FLAG) return domain ^ SOLVED_FLAG;\n    // For simplicity sake, convert them back to arrays\n    domain = domain_numToStr(domain);\n  }\n\n  // TODO: domain_middleElementNum(domain);\n  return domain_str_middleElement(domain);\n}\n\nfunction domain_str_middleElement(domain) {\n  ASSERT_STRDOM(domain);\n\n  if (!domain) return NO_SUCH_VALUE;\n\n  const size = domain_str_size(domain);\n  let targetValue = FLOOR(size / 2);\n\n  let lo;\n  let hi;\n  for (let i = 0, len = domain.length; i < len; i += STR_RANGE_SIZE) {\n    lo = domain_str_decodeValue(domain, i);\n    hi = domain_str_decodeValue(domain, i + STR_VALUE_SIZE);\n\n    const count = 1 + hi - lo;\n    if (targetValue < count) {\n      break;\n    }\n\n    targetValue -= count;\n  }\n\n  // `targetValue` should be the `nth` element in the current range (`lo-hi`)\n  // so we can use `lo` and add the remainder of `targetValue` to get the mid value\n  return lo + targetValue;\n}\n\n/**\n * Get lowest value in the domain\n * Only use if callsite doesn't need to cache first range (because array access)\n *\n * @param {$nordom} domain\n * @returns {number}\n */\nfunction domain_min(domain) {\n  ASSERT_NORDOM(domain);\n\n  if (typeof domain === 'number') return domain_num_min(domain);\n  return domain_str_min(domain);\n}\n\nfunction domain_num_min(domain) {\n  ASSERT_NUMDOM(domain);\n\n  if (domain >= SOLVED_FLAG) return domain_sol_min(domain);\n  return domain_bit_min(domain);\n}\n\nfunction domain_sol_min(domain) {\n  ASSERT_SOLDOM(domain);\n\n  return domain ^ SOLVED_FLAG;\n}\n\nconst { _domain_bit_min } = (function(stdlib) {\n  //'use asm';\n  var clz = stdlib.Math.clz32;\n\n  function _domain_bit_min(domain) {\n    domain = domain | 0;\n\n    // fast paths: these are by far the most used case in our situation\n    switch (domain | 0) {\n      case 0: return -1;\n      case 1: return 0;\n      case 2: return 1;\n      case 3: return 0;\n      default: break;\n    }\n    // 1. Fill in all the higher bits after the first one\n    // ASMjs for some reason does not allow ^=,&=, or |=\n    domain = domain | (domain << 16);\n    domain = domain | (domain << 8);\n    domain = domain | (domain << 4);\n    domain = domain | (domain << 2);\n    domain = domain | (domain << 1);\n    // 2. Now, inversing the bits (including the first set\n    // bit, which becomes unset) reveals the lowest bits\n    return 32 - clz(~domain) | 0;\n  }\n  return { _domain_bit_min };\n})({ Math: { clz32: Math.clz32 }});\n\nfunction domain_bit_min(domain) {\n  ASSERT_BITDOM(domain);\n\n  return _domain_bit_min(domain) | 0;\n}\n\nfunction domain_str_min(domain) {\n  ASSERT_STRDOM(domain);\n  if (!domain) return NO_SUCH_VALUE;\n\n  return domain_str_decodeValue(domain, STR_FIRST_RANGE_LO);\n}\n\n/**\n * Only use if callsite doesn't use last range again\n *\n * @param {$nordom} domain\n * @returns {number} can be NO_SUCH_VALUE\n */\nfunction domain_max(domain) {\n  ASSERT_NORDOM(domain);\n\n  if (typeof domain === 'number') return domain_num_max(domain);\n  return domain_str_max(domain);\n}\n\nfunction domain_num_max(domain) {\n  ASSERT_NUMDOM(domain);\n\n  if (domain >= SOLVED_FLAG) return domain_sol_max(domain);\n  return domain_bit_max(domain);\n}\n\nfunction domain_sol_max(domain) {\n  ASSERT_SOLDOM(domain);\n\n  return domain ^ SOLVED_FLAG;\n}\n\nconst { _domain_bit_max } = (function(stdlib) {\n  //'use asm';\n  var clz = stdlib.Math.clz32;\n\n  function _domain_bit_max(domain) {\n    domain = domain | 0;\n\n    // Fast paths: these are by far the most used case in our situation\n    // (the empty domain check is \"free\" here)\n\n    switch (domain | 0) {\n      case 0:\n        return -1; // Empty domain\n      case 1:\n        return 0; // Should not be possible. implies a soldom\n      case 2:\n        return 1;\n      case 3:\n        return 1;\n      default:\n        break;\n    }\n    return 31 - clz(domain) | 0;\n  }\n  return { _domain_bit_max };\n})({ Math: { clz32: Math.clz32 }});\n\nfunction domain_bit_max(domain) {\n  ASSERT_BITDOM(domain);\n\n  return _domain_bit_max(domain) | 0;\n}\n\nfunction domain_str_max(domain) {\n  ASSERT_STRDOM(domain);\n  if (!domain) return NO_SUCH_VALUE;\n\n  // Last encoded value in the string should be the hi of the last range. so max is last value\n  return domain_str_decodeValue(domain, domain.length - STR_VALUE_SIZE);\n}\n\nfunction domain_arr_max(domain) {\n  ASSERT_ARRDOM(domain);\n\n  const len = domain.length;\n  if (len === 0) return NO_SUCH_VALUE;\n  return domain[len - 1];\n}\n\n/**\n * A domain is \"solved\" if it covers exactly one value. It is not solved if it is empty.\n *\n * @param {$nordom} domain\n * @returns {boolean}\n */\nfunction domain_isSolved(domain) {\n  ASSERT_NORDOM(domain, true, domain__debug);\n  ASSERT(\n    ((domain & SOLVED_FLAG) !== 0) === domain >= SOLVED_FLAG,\n    'if flag is set the num should be gte to flag'\n  );\n\n  return typeof domain === 'number' && domain >= SOLVED_FLAG;\n}\n\n/**\n * Purely checks whether given domain is solved to zero\n *\n * @param {$nordom} domain\n * @returns {boolean}\n */\nfunction domain_isZero(domain) {\n  ASSERT_NORDOM(domain);\n\n  return domain === DOM_ZERO;\n}\n\n/**\n * Purely checks whether given domain does not contain the value zero\n *\n * @param {$nordom} domain\n * @returns {boolean}\n */\nfunction domain_hasNoZero(domain) {\n  ASSERT_NORDOM(domain);\n  return !domain_hasZero(domain); // This roundabout way of checking ensures true when the domain is empty\n}\n\n/**\n * Does the domain have, at least, a zero? This may be a\n * domain that is solved to zero but not necessarily.\n *\n * @param {$nordom} domain\n * @returns {boolean}\n */\nfunction domain_hasZero(domain) {\n  ASSERT_NORDOM(domain);\n  return domain_min(domain) === 0;\n}\n\n/**\n * Is the var strictly the domain [0, 1] ?\n *\n * @param {$nordom} domain\n * @returns {boolean}\n */\nfunction domain_isBool(domain) {\n  return domain === DOM_BOOL;\n}\n\n/**\n * Does the domain have a zero and one nonzero value?\n *\n * @param {$nordom} domain\n * @returns {boolean}\n */\nfunction domain_isBoolyPair(domain) {\n  ASSERT_NORDOM(domain);\n  return domain_isBooly(domain) && domain_size(domain) === 2;\n}\n\n/**\n * Does the domain have a zero and a nonzero value?\n *\n * @param {$nordom} domain\n * @returns {boolean}\n */\nfunction domain_isBooly(domain) {\n  ASSERT_NORDOM(domain);\n  return (\n    domain_isBool(domain) || (!domain_isZero(domain) && domain_hasZero(domain))\n  );\n}\n\n/**\n * Treat domain as booly (\"zero or nonzero\")\n * If result then remove the zero, otherwise remove anything nonzero\n * The result should be either the domain solved to zero or any domain that contains no zero. Well or the empty domain.\n *\n * @param {$nordom} domain\n * @param {boolean} result\n * @returns {$nordom}\n */\nfunction domain_resolveAsBooly(domain, result) {\n  return result\n    ? domain_removeValue(domain, 0)\n    : domain_removeGtUnsafe(domain, 0);\n}\n\n/**\n * Is given domain empty?\n * Assuming a nordom, the only value that returns true is EMPTY.\n * Minifier or browser should eliminate this function.\n *\n * @param {$nordom} domain\n * @returns {boolean}\n */\nfunction domain_isEmpty(domain) {\n  ASSERT(domain !== '', 'never use empty string as rejected domain');\n  ASSERT_NORDOM(domain);\n  return domain === EMPTY;\n}\n\n/**\n * Remove all values from domain that are greater\n * than or equal to given value\n *\n * @param {$domain} domain\n * @param {number} value\n * @returns {$domain}\n */\nfunction domain_removeGte(domain, value) {\n  ASSERT_NORDOM(domain);\n  ASSERT(\n    typeof value === 'number' && value >= SUB - 1 && value <= SUP + 1,\n    'VALUE_SHOULD_BE_VALID_DOMAIN_ELEMENT',\n    domain__debug(domain),\n    value\n  ); // Or +-1...\n\n  if (typeof domain === 'number') return domain_num_removeGte(domain, value);\n  return domain_str_removeGte(domain, value);\n}\n\nfunction domain_num_removeGte(domain, value) {\n  ASSERT_NUMDOM(domain);\n\n  if (domain >= SOLVED_FLAG) return domain_sol_removeGte(domain, value);\n  return domain_bitToSmallest(domain_bit_removeGte(domain, value));\n}\n\nfunction domain_sol_removeGte(domain, value) {\n  ASSERT_SOLDOM(domain);\n  // (could we just do `return (domain >= (value|SOLVED_FLAG)) ? EMPTY : domain` ?)\n  const solvedValue = domain ^ SOLVED_FLAG;\n  if (solvedValue >= value) return EMPTY;\n  return domain; // No change\n}\n\n/**\n * Remove all values from domain that are greater\n * than or equal to given value\n *\n * @param {$numdom} domain\n * @param {number} value NOT a flag\n * @returns {$numdom}\n */\nfunction domain_bit_removeGte(domain, value) {\n  switch (value) {\n    case 0:\n      return 0;\n    case 1:\n      return domain & 0x00000001;\n    case 2:\n      return domain & 0x00000003;\n    case 3:\n      return domain & 0x00000007;\n    case 4:\n      return domain & 0x0000000f;\n    case 5:\n      return domain & 0x0000001f;\n    case 6:\n      return domain & 0x0000003f;\n    case 7:\n      return domain & 0x0000007f;\n    case 8:\n      return domain & 0x000000ff;\n    case 9:\n      return domain & 0x000001ff;\n    case 10:\n      return domain & 0x000003ff;\n    case 11:\n      return domain & 0x000007ff;\n    case 12:\n      return domain & 0x00000fff;\n    case 13:\n      return domain & 0x00001fff;\n    case 14:\n      return domain & 0x00003fff;\n    case 15:\n      return domain & 0x00007fff;\n    case 16:\n      return domain & 0x0000ffff;\n    case 17:\n      return domain & 0x0001ffff;\n    case 18:\n      return domain & 0x0003ffff;\n    case 19:\n      return domain & 0x0007ffff;\n    case 20:\n      return domain & 0x000fffff;\n    case 21:\n      return domain & 0x001fffff;\n    case 22:\n      return domain & 0x003fffff;\n    case 23:\n      return domain & 0x007fffff;\n    case 24:\n      return domain & 0x00ffffff;\n    case 25:\n      return domain & 0x01ffffff;\n    case 26:\n      return domain & 0x03ffffff;\n    case 27:\n      return domain & 0x07ffffff;\n    case 28:\n      return domain & 0x0fffffff;\n    case 29:\n      return domain & 0x1fffffff;\n    case 30:\n      return domain & 0x3fffffff;\n  }\n\n  return domain; // When value > 30\n}\n\n/**\n * Remove any value from domain that is bigger than or equal to given value.\n * Since domains are assumed to be in CSIS form, we can start from the back and\n * search for the first range that is smaller or contains given value. Prune\n * any range that follows it and trim the found range if it contains the value.\n * Returns whether the domain was changed somehow.\n *\n * @param {$strdom} strdom\n * @param {number} value\n * @returns {$strdom}\n */\nfunction domain_str_removeGte(strdom, value) {\n  ASSERT_STRDOM(strdom);\n\n  for (let i = 0, len = strdom.length; i < len; i += STR_RANGE_SIZE) {\n    const lo = domain_str_decodeValue(strdom, i);\n    const hi = domain_str_decodeValue(strdom, i + STR_VALUE_SIZE);\n\n    // Case: v=5\n    // 012 456 // => 012 4\n    // 012 45  // => 012 4\n    // 012 567 // => 012\n    // 012 5   // => 012\n    // 012 678 // => 012\n    // 012     // => NONE\n    // 678     // => empty\n\n    // TODO: if we know the returned domain is a small domain we should prevent the slice at all.\n\n    if (lo >= value) {\n      // >\n      // 67 9    -> empty\n      // 012 789 -> 012\n      // ==\n      // 567 9   -> empty\n      // 012 567 -> 012\n      // 012 5   -> 012\n      // 5       ->\n      if (!i) return EMPTY;\n      return domain_toSmallest(strdom.slice(0, i));\n    }\n\n    if (value <= hi) {\n      if (i === 0 && value === lo + 1) {\n        // Domain_createValue(lo);\n        const slo = strdom.slice(0, STR_VALUE_SIZE);\n        return domain_toSmallest(slo + slo);\n      }\n\n      // 012 456 -> 012 4\n      // 012 45  -> 012 4\n      const newDomain =\n        strdom.slice(0, i + STR_VALUE_SIZE) + domain_str_encodeValue(value - 1);\n      ASSERT(newDomain.length > STR_VALUE_SIZE, 'cannot be a solved value');\n      // If (value - 1 <= SMALL_MAX_NUM) return newDomain;\n      return domain_toSmallest(newDomain);\n    }\n  }\n\n  return strdom; // 012 -> 012\n}\n\n/**\n * Remove all values from domain that are lower\n * than or equal to given value\n *\n * @param {$domain} domain\n * @param {number} value\n * @returns {$domain}\n */\nfunction domain_removeLte(domain, value) {\n  ASSERT_NORDOM(domain);\n  ASSERT(\n    typeof value === 'number' && value >= SUB - 1 && value <= SUP + 1,\n    'VALUE_SHOULD_BE_VALID_DOMAIN_ELEMENT',\n    domain__debug(domain),\n    value\n  ); // Or +-1...\n\n  if (typeof domain === 'number') return domain_num_removeLte(domain, value);\n  return domain_str_removeLte(domain, value);\n}\n\nfunction domain_num_removeLte(domain, value) {\n  ASSERT_NUMDOM(domain);\n\n  if (domain >= SOLVED_FLAG) return domain_sol_removeLte(domain, value);\n  return domain_toSmallest(domain_bit_removeLte(domain, value));\n}\n\nfunction domain_sol_removeLte(domain, value) {\n  // (could we just do `return (domain <= (value|SOLVED_FLAG)) ? EMPTY : domain` ?)\n  const solvedValue = domain ^ SOLVED_FLAG;\n  if (solvedValue <= value) return EMPTY;\n  return domain; // No change\n}\n\n/**\n * Remove all values from domain that are lower\n * than or equal to given value\n *\n * @param {$numdom} domain\n * @param {number} value NOT a flag\n * @returns {$numdom}\n */\nfunction domain_bit_removeLte(domain, value) {\n  switch (value) {\n    case 0:\n      return domain & 0x7ffffffe;\n    case 1:\n      return domain & 0x7ffffffc;\n    case 2:\n      return domain & 0x7ffffff8;\n    case 3:\n      return domain & 0x7ffffff0;\n    case 4:\n      return domain & 0x7fffffe0;\n    case 5:\n      return domain & 0x7fffffc0;\n    case 6:\n      return domain & 0x7fffff80;\n    case 7:\n      return domain & 0x7fffff00;\n    case 8:\n      return domain & 0x7ffffe00;\n    case 9:\n      return domain & 0x7ffffc00;\n    case 10:\n      return domain & 0x7ffff800;\n    case 11:\n      return domain & 0x7ffff000;\n    case 12:\n      return domain & 0x7fffe000;\n    case 13:\n      return domain & 0x7fffc000;\n    case 14:\n      return domain & 0x7fff8000;\n    case 15:\n      return domain & 0x7fff0000;\n    case 16:\n      return domain & 0x7ffe0000;\n    case 17:\n      return domain & 0x7ffc0000;\n    case 18:\n      return domain & 0x7ff80000;\n    case 19:\n      return domain & 0x7ff00000;\n    case 20:\n      return domain & 0x7fe00000;\n    case 21:\n      return domain & 0x7fc00000;\n    case 22:\n      return domain & 0x7f800000;\n    case 23:\n      return domain & 0x7f000000;\n    case 24:\n      return domain & 0x7e000000;\n    case 25:\n      return domain & 0x7c000000;\n    case 26:\n      return domain & 0x78000000;\n    case 27:\n      return domain & 0x70000000;\n    case 28:\n      return domain & 0x60000000;\n    case 29:\n      return domain & 0x40000000;\n    case 30:\n      return 0; // Assuming domain is \"valid\" this should remove all elements\n  }\n\n  if (value < 0) return domain;\n  ASSERT(value > SMALL_MAX_NUM, 'if not below zero than above max');\n  return 0;\n}\n\n/**\n * Remove any value from domain that is lesser than or equal to given value.\n * Since domains are assumed to be in CSIS form, we can start from the front and\n * search for the first range that is smaller or contains given value. Prune\n * any range that preceeds it and trim the found range if it contains the value.\n * Returns whether the domain was changed somehow\n * Does not harm domain\n *\n * @param {$strdom} strdom\n * @param {number} value\n * @returns {$nordom}\n */\nfunction domain_str_removeLte(strdom, value) {\n  ASSERT_STRDOM(strdom);\n\n  for (let i = 0, len = strdom.length; i < len; i += STR_RANGE_SIZE) {\n    const lo = domain_str_decodeValue(strdom, i);\n    const hi = domain_str_decodeValue(strdom, i + STR_VALUE_SIZE);\n\n    // Case: v=5\n    // 456 89 => 6 89\n    // 45 89  => 89\n    // 56 89  => 6 89\n    // 5  89  => 5 89\n    // 6788   => 67 9\n    // 789    => NONE\n    // 012    => empty\n\n    if (lo > value) {\n      // 678 -> 678\n      if (!i) return domain_toSmallest(strdom);\n\n      // 234 678 -> 678\n      return domain_toSmallest(strdom.slice(i));\n    }\n\n    if (hi === value) {\n      // 45 89  => 89\n      // 5  89  => 5 89\n      // 15     =>\n      if (i >= len - STR_RANGE_SIZE) return EMPTY;\n      return domain_toSmallest(strdom.slice(i + STR_RANGE_SIZE));\n    }\n\n    if (value <= hi) {\n      // 456 89 => 6 89\n      // 56 89  => 6 89\n\n      return domain_toSmallest(\n        domain_str_encodeValue(value + 1) + strdom.slice(i + STR_VALUE_SIZE)\n      );\n    }\n  }\n\n  return EMPTY; // 012 -> empty\n}\n\n/**\n * Removes all values lower than value.\n * Only \"unsafe\" in the sense that no flag is raised\n * for oob values (<-1 or >sup+1) or non-numeric values.\n * This unsafeness simplifies other code significantly.\n *\n * @param {$nordom} domain\n * @param {number} value\n * @returns {$nordom}\n */\nfunction domain_removeLtUnsafe(domain, value) {\n  ASSERT_NORDOM(domain);\n  ASSERT(typeof value === 'number', 'Expecting a numerical value');\n\n  if (value <= SUB) return domain;\n  if (value > SUP) return domain_createEmpty();\n  return domain_removeLte(domain, value - 1);\n}\n\n/**\n * Removes all values lower than value.\n * Only \"unsafe\" in the sense that no flag is raised\n * for oob values (<-1 or >sup+1) or non-numeric values\n * This unsafeness simplifies other code significantly.\n *\n * @param {$nordom} domain\n * @param {number} value\n * @returns {$nordom}\n */\nfunction domain_removeGtUnsafe(domain, value) {\n  ASSERT_NORDOM(domain);\n  ASSERT(typeof value === 'number', 'Expecting a numerical value');\n\n  if (value >= SUP) return domain;\n  if (value < SUB) return domain_createEmpty();\n  return domain_removeGte(domain, value + 1);\n}\n\n/**\n * Remove given value from given domain and return\n * the new domain that doesn't contain it.\n *\n * @param {$domain} domain\n * @param {number} value\n * @returns {$domain}\n */\nfunction domain_removeValue(domain, value) {\n  ASSERT_NORDOM(domain);\n  ASSERT(\n    typeof value === 'number' && value >= 0,\n    'VALUE_SHOULD_BE_VALID_DOMAIN_ELEMENT',\n    value\n  ); // So cannot be negative\n\n  if (typeof domain === 'number') return domain_num_removeValue(domain, value);\n  return domain_toSmallest(domain_str_removeValue(domain, value));\n}\n\n/**\n * @param {$numdom} domain\n * @param {number} value\n * @returns {$domain}\n */\nfunction domain_num_removeValue(domain, value) {\n  if (domain >= SOLVED_FLAG) return domain_sol_removeValue(domain, value);\n  return domain_bit_removeValue(domain, value);\n}\n\nfunction domain_sol_removeValue(domain, value) {\n  if (value === (domain ^ SOLVED_FLAG)) return EMPTY;\n  return domain;\n}\n\n/**\n * @param {$bitdom} domain\n * @param {number} value NOT a flag\n * @returns {$bitdom}\n */\nfunction domain_bit_removeValue(domain, value) {\n  if (value > 30) return domain_toSmallest(domain); // Though probably already fine, we dont know what `domain` is here\n  const flag = 1 << value;\n  return domain_bitToSmallest((domain | flag) ^ flag);\n}\n\n/**\n * @param {$strdom} domain\n * @param {number} value\n * @returns {$domain} should be smallest\n */\nfunction domain_str_removeValue(domain, value) {\n  ASSERT_STRDOM(domain);\n\n  let lastLo = -1;\n  let lastHi = -1;\n  for (let i = 0, len = domain.length; i < len; i += STR_RANGE_SIZE) {\n    const lo = domain_str_decodeValue(domain, i);\n    // Domain is CSIS so once a range was found beyond value, no further ranges can possibly wrap value. return now.\n    if (value < lo) break;\n\n    const hi = domain_str_decodeValue(domain, i + STR_VALUE_SIZE);\n    if (value <= hi) {\n      return _domain_str_removeValue(\n        domain,\n        len,\n        i,\n        lo,\n        hi,\n        value,\n        lastLo,\n        lastHi\n      );\n    }\n\n    lastLo = lo;\n    lastHi = hi;\n  }\n\n  // \"no change\" because domain was not found.\n  return domain;\n}\n\nfunction _domain_str_removeValue(\n  domain,\n  len,\n  index,\n  lo,\n  hi,\n  value,\n  lastLo,\n  lastHi\n) {\n  ASSERT_STRDOM(domain);\n  ASSERT(domain, 'SHOULD_NOT_BE_EMPTY_YET');\n\n  // Normalize to (solved) numdom if the result is solved:\n  // - one range and it contains two values: solved numdom\n  // - oen range and it contains one value: EMPTY\n  // - two ranges and both have one value: solved numdom\n  // - removed value is >MAX_NUMDOM_VALUE and new highest value <=MAX_NUMDOM_VALUE: numdom\n  //   - must remove highest value of dom. either\n  //     - from a range of >=2 values (check hi-1)\n  //     - from range with one value (check lastHi)\n  if (len === STR_RANGE_SIZE) {\n    if (hi - lo === 1) return ((lo === value ? hi : lo) | SOLVED_FLAG) >>> 0;\n    if (lo === hi) return EMPTY;\n    ASSERT(hi - lo > 1);\n  } else if (\n    index &&\n    len === 2 * STR_RANGE_SIZE &&\n    lo === hi &&\n    lastLo === lastHi\n  ) {\n    return (lastLo | SOLVED_FLAG) >>> 0;\n  }\n\n  if (index === len - STR_RANGE_SIZE && value === hi) {\n    // To numdom checks\n    if (lo === hi && lastHi <= SMALL_MAX_NUM) {\n      ASSERT(len > STR_RANGE_SIZE, 'this return-EMPTY case is checked above');\n      // Numdom excluding the last range\n      const newLen = len - STR_RANGE_SIZE;\n      return domain_strToBit(domain.slice(0, newLen), newLen);\n    }\n\n    if (hi - 1 <= SMALL_MAX_NUM) {\n      ASSERT(\n        len > STR_RANGE_SIZE || hi - lo > 2,\n        'one-range check done above, would return solved numdom'\n      );\n      // Numdom excluding last value of last range\n      // (the encodeValue step is unfortunate but let's KISS)\n      return domain_strToBit(\n        domain.slice(0, -STR_VALUE_SIZE) + domain_str_encodeValue(hi - 1),\n        len\n      );\n    }\n  }\n\n  // From this point onward we'll return a strdom\n\n  const before = domain.slice(0, index);\n  const after = domain.slice(index + STR_RANGE_SIZE);\n\n  if (hi === value) {\n    if (lo === value) {\n      // Lo=hi=value; drop this range completely\n      return before + after;\n    }\n\n    return before + domain_str_encodeRange(lo, hi - 1) + after;\n  }\n\n  if (lo === value) {\n    return before + domain_str_encodeRange(lo + 1, hi) + after;\n  }\n\n  // We get new two ranges...\n  return (\n    before +\n    domain_str_encodeRange(lo, value - 1) +\n    domain_str_encodeRange(value + 1, hi) +\n    after\n  );\n}\n\n/**\n * Check if every element in one domain not\n * occur in the other domain and vice versa\n *\n * @param {$domain} domain1\n * @param {$domain} domain2\n * @returns {boolean}\n */\nfunction domain_sharesNoElements(domain1, domain2) {\n  ASSERT_NORDOM(domain1);\n  ASSERT_NORDOM(domain2);\n\n  const isNum1 = typeof domain1 === 'number';\n  const isNum2 = typeof domain2 === 'number';\n  if (isNum1 && isNum2) return domain_numnum_sharesNoElements(domain1, domain2);\n  if (isNum1) return domain_numstr_sharesNoElements(domain1, domain2);\n  if (isNum2) return domain_numstr_sharesNoElements(domain2, domain1);\n  return domain_strstr_sharesNoElements(domain1, domain2);\n}\n\nfunction domain_numnum_sharesNoElements(domain1, domain2) {\n  if (domain1 >= SOLVED_FLAG) {\n    if (domain2 >= SOLVED_FLAG)\n      return domain_solsol_sharesNoElements(domain1, domain2);\n    return domain_solbit_sharesNoElements(domain1, domain2);\n  }\n\n  if (domain2 >= SOLVED_FLAG)\n    return domain_solbit_sharesNoElements(domain2, domain1);\n  return domain_bitbit_sharesNoElements(domain1, domain2);\n}\n\nfunction domain_solsol_sharesNoElements(domain1, domain2) {\n  return domain1 !== domain2;\n}\n\nfunction domain_solbit_sharesNoElements(soldom, bitsol) {\n  const solvedValue = soldom ^ SOLVED_FLAG;\n  if (solvedValue > SMALL_MAX_NUM) return true;\n  return (bitsol & (1 << solvedValue)) === 0;\n}\n\n/**\n * Check if every element in one domain does not\n * occur in the other domain and vice versa\n *\n * @param {$numdom} domain1\n * @param {$numdom} domain2\n * @returns {boolean}\n */\nfunction domain_bitbit_sharesNoElements(domain1, domain2) {\n  // Checks whether not a single bit in set in _both_ domains\n  return (domain1 & domain2) === 0;\n}\n\n/**\n * Check if every element in one domain not\n * occur in the other domain and vice versa\n *\n * @param {$numdom} numdom\n * @param {$strdom} strdom\n * @returns {boolean}\n */\nfunction domain_numstr_sharesNoElements(numdom, strdom) {\n  ASSERT_NUMDOM(numdom);\n  ASSERT_STRDOM(strdom);\n\n  if (numdom >= SOLVED_FLAG)\n    return domain_solstr_sharesNoElements(numdom, strdom);\n  return domain_bitstr_sharesNoElements(numdom, strdom);\n}\n\nfunction domain_solstr_sharesNoElements(soldom, strdom) {\n  const solvedValue = soldom ^ SOLVED_FLAG;\n  for (\n    let strIndex = 0, strlen = strdom.length;\n    strIndex < strlen;\n    strIndex += STR_RANGE_SIZE\n  ) {\n    const lo = domain_str_decodeValue(strdom, strIndex);\n    const hi = domain_str_decodeValue(strdom, strIndex + STR_VALUE_SIZE);\n    if (solvedValue < lo) return true; // Solved value not found so element not shared\n    if (solvedValue <= hi) return false; // Solved value is in current range so element shared\n  }\n\n  // Did not find a range that contained value so no element shared\n  return true;\n}\n\nfunction domain_bitstr_sharesNoElements(bitdom, strdom) {\n  ASSERT_BITDOM(bitdom);\n  ASSERT_STRDOM(strdom);\n\n  let strIndex = 0;\n  const strlen = strdom.length;\n  for (let numIndex = 0; numIndex <= SMALL_MAX_NUM; ++numIndex) {\n    if (bitdom & (1 << numIndex)) {\n      // Find numIndex (as value) in domain_str. return true when\n      // found. return false if number above small_max_num is found\n      while (strIndex < strlen) {\n        const lo = domain_str_decodeValue(strdom, strIndex);\n        const hi = domain_str_decodeValue(strdom, strIndex + STR_VALUE_SIZE);\n\n        // There is overlap if numIndex is within current range so return false\n        if (numIndex >= lo && numIndex <= hi) return false;\n        // The next value in domain_num can not be smaller and the previous\n        // domain_str range was below that value and the next range is beyond\n        // the small domain max so there can be no more matching values\n        if (lo > SMALL_MAX_NUM) return true;\n        // This range is bigger than target value so the value doesnt\n        // exist; skip to next value\n        if (lo > numIndex) break;\n\n        strIndex += STR_RANGE_SIZE;\n      }\n\n      if (strIndex >= strlen) return true;\n    }\n  }\n\n  return true; // Dead code?\n}\n\n/**\n * Check if every element in one domain not\n * occur in the other domain and vice versa\n *\n * @param {$strdom} domain1\n * @param {$strdom} domain2\n * @returns {boolean}\n */\nfunction domain_strstr_sharesNoElements(domain1, domain2) {\n  ASSERT_STRDOM(domain1);\n  ASSERT_STRDOM(domain2);\n\n  const len1 = domain1.length;\n  const len2 = domain2.length;\n\n  let index1 = 0;\n  let index2 = 0;\n\n  let lo1 = domain_str_decodeValue(domain1, STR_FIRST_RANGE_LO);\n  let hi1 = domain_str_decodeValue(domain1, STR_FIRST_RANGE_HI);\n  let lo2 = domain_str_decodeValue(domain2, STR_FIRST_RANGE_LO);\n  let hi2 = domain_str_decodeValue(domain2, STR_FIRST_RANGE_HI);\n\n  while (true) {\n    if (hi1 < lo2) {\n      index1 += STR_RANGE_SIZE;\n      if (index1 >= len1) break;\n      lo1 = domain_str_decodeValue(domain1, index1);\n      hi1 = domain_str_decodeValue(domain1, index1 + STR_VALUE_SIZE);\n    } else if (hi2 < lo1) {\n      index2 += STR_RANGE_SIZE;\n      if (index2 >= len2) break;\n      lo2 = domain_str_decodeValue(domain2, index2);\n      hi2 = domain_str_decodeValue(domain2, index2 + STR_VALUE_SIZE);\n    } else {\n      ASSERT(\n        (lo1 <= lo2 && lo2 <= hi1) || (lo2 <= lo1 && lo1 <= hi2),\n        'domain_strstr_sharesNoElements: both ranges must overlap at least for some element because neither ends before the other [' +\n          lo1 +\n          ',' +\n          hi1 +\n          ' - ' +\n          lo2 +\n          ',' +\n          hi2 +\n          ']'\n      );\n      return false;\n    }\n  }\n\n  // No overlaps found\n  return true;\n}\n\n/**\n * @param {number} value\n * @returns {$domain} will be a soldom\n */\nfunction domain_createValue(value) {\n  ASSERT(\n    value >= SUB,\n    'domain_createValue: value should be within valid range',\n    SUB,\n    '<=',\n    value\n  );\n  ASSERT(\n    value <= SUP,\n    'domain_createValue: value should be within valid range',\n    SUP,\n    '>=',\n    value\n  );\n\n  return (value | SOLVED_FLAG) >>> 0;\n}\n\n/**\n * @param {number} lo\n * @param {number} hi\n * @returns {$nordom}\n */\nfunction domain_createRange(lo, hi) {\n  ASSERT(lo >= SUB, 'lo should be >= SUB', lo, hi);\n  ASSERT(hi <= SUP, 'hi should be <= SUP', lo, hi);\n  ASSERT(lo <= hi, 'should be lo<=hi', lo, hi);\n  if (lo === hi) return domain_createValue(lo);\n  if (hi <= SMALL_MAX_NUM) return domain_num_createRange(lo, hi);\n  return domain_str_encodeRange(lo, hi);\n}\n\n/**\n * Create a new domain by passing on the bounds. If the bounds are OOB they\n * are trimmed. This can return the empty domain if both lo and hi are OOB.\n *\n * @param {number} lo\n * @param {number} hi\n * @returns {$nordom}\n */\nfunction domain_createRangeTrimmed(lo, hi) {\n  ASSERT(lo <= hi, 'should be lo<=hi', lo, hi);\n  if (hi < SUB || lo > SUP) return EMPTY;\n  return domain_createRange(Math.max(SUB, lo), Math.min(SUP, hi));\n}\n\n/**\n * @param {number} lo\n * @param {number} hi\n * @returns {$bitdom}\n */\nfunction domain_num_createRange(lo, hi) {\n  return ((1 << (1 + hi - lo)) - 1) << lo;\n}\n\n/**\n * This function mainly prevents leaking EMPTY outside of domain.js\n * Browsers should optimize this away, if the minifier didn't already.\n *\n * @returns {$numdom}\n */\nfunction domain_createEmpty() {\n  return EMPTY;\n}\n\nfunction domain_createBoolyPair(value) {\n  if (value === 0) return domain_createValue(0);\n  if (value === 1) return domain_createRange(0, 1);\n  return domain_arrToSmallest([0, 0, value, value]); // Meh. we can optimize this if it turns out a perf issue\n}\n\n/**\n * Return a domain containing all numbers from zero to the highest\n * number in given domain. In binary this means we'll set all the\n * bits of lower value than the most-significant set bit.\n *\n * @param {$numdom} domain_num Must be > ZERO\n * @returns {$domain} never solved since that requires ZERO to be a valid input, which it isnt\n */\nfunction domain_numnum_createRangeZeroToMax(domain_num) {\n  ASSERT_NUMDOM(domain_num);\n  ASSERT(domain_num < SOLVED_FLAG, 'should not be solved num');\n  ASSERT(\n    domain_num !== 1 << 0,\n    'INVALID INPUT, ZERO would be a solved domain which is caught elsewhere'\n  );\n\n  // If (domain_num === (1 << 0)) return SOLVED_FLAG; // note: SOLVED_FLAG|0 === SOLVED_FLAG.\n\n  domain_num |= domain_num >> 1;\n  domain_num |= domain_num >> 2;\n  domain_num |= domain_num >> 4;\n  domain_num |= domain_num >> 8;\n  domain_num |= domain_num >> 16;\n  return domain_num;\n}\n\n/**\n * Get a domain representation in array form\n *\n * @param {$domain} domain\n * @param {boolean} [clone] If input is array, slice the array? (other cases will always return a fresh array)\n * @returns {$arrdom} (small domains will also be arrays)\n */\nfunction domain_toArr(domain, clone) {\n  if (typeof domain === 'number') return domain_numToArr(domain);\n  if (typeof domain === 'string') return domain_strToArr(domain);\n  ASSERT(Array.isArray(domain), 'can only be array now');\n  if (clone) return domain.slice(0);\n  return domain;\n}\n\nfunction domain_numToArr(domain) {\n  ASSERT_NUMDOM(domain);\n\n  if (domain >= SOLVED_FLAG) return domain_solToArr(domain);\n  return domain_bitToArr(domain);\n}\n\nfunction domain_solToArr(domain) {\n  const solvedValue = domain ^ SOLVED_FLAG;\n  return [solvedValue, solvedValue];\n}\n\nfunction domain_bitToArr(domain) {\n  if (domain === EMPTY) return [];\n  const arr = [];\n  let lo = -1;\n  let hi = -1;\n\n  if ((1 << 0) & domain) {\n    lo = 0;\n    hi = 0;\n  }\n\n  if ((1 << 1) & domain) {\n    if (lo !== 0) {\n      // Lo is either 0 or nothing\n      lo = 1;\n    }\n\n    hi = 1; // There cannot be a gap yet\n  }\n\n  if ((1 << 2) & domain) {\n    if (hi === 0) {\n      arr.push(0, 0);\n      lo = 2;\n    } else if (hi !== 1) {\n      // If hi isnt 0 and hi isnt 1 then hi isnt set and so lo isnt set\n      lo = 2;\n    }\n\n    hi = 2;\n  }\n\n  if ((1 << 3) & domain) {\n    if (hi < 0) {\n      // This is the LSB that is set\n      lo = 3;\n    } else if (hi !== 2) {\n      // There's a gap so push prev range now\n      arr.push(lo, hi);\n      lo = 3;\n    }\n\n    hi = 3;\n  }\n\n  // Is the fifth bit or higher even set at all? for ~85% that is not the case at this point\n  if (domain >= 1 << 4) {\n    for (let i = 4; i <= SMALL_MAX_NUM; ++i) {\n      if (domain & (1 << i)) {\n        if (hi < 0) {\n          // This is the LSB that is set\n          lo = i;\n        } else if (hi !== i - 1) {\n          // There's a gap so push prev range now\n          arr.push(lo, hi);\n          lo = i;\n        }\n\n        hi = i;\n      }\n    }\n  }\n\n  // Since the domain wasn't empty (checked at start) there\n  // must now be an unpushed lo/hi pair left to push...\n  arr.push(lo, hi);\n\n  return arr;\n}\n\nfunction domain_strToArr(domain) {\n  ASSERT_STRDOM(domain);\n\n  if (domain === EMPTY) return [];\n\n  const arr = [];\n  for (let i = 0, len = domain.length; i < len; i += STR_RANGE_SIZE) {\n    const lo = domain_str_decodeValue(domain, i);\n    const hi = domain_str_decodeValue(domain, i + STR_VALUE_SIZE);\n\n    arr.push(lo, hi);\n  }\n\n  return arr;\n}\n\n/**\n * Get a domain representation in string form\n *\n * @param {$domain} domain\n * @returns {$strdom} (small domains will also be strings)\n */\nfunction domain_toStr(domain) {\n  if (typeof domain === 'number') return domain_numToStr(domain);\n  if (typeof domain === 'string') return domain;\n  ASSERT(Array.isArray(domain), 'can only be array now');\n  return domain_arrToStr(domain);\n}\n\nfunction domain_numToStr(domain) {\n  if (domain >= SOLVED_FLAG) return domain_solToStr(domain);\n  return domain_bitToStr(domain);\n}\n\nfunction domain_solToStr(domain) {\n  const solvedValue = domain ^ SOLVED_FLAG;\n  return domain_str_encodeRange(solvedValue, solvedValue);\n}\n\nfunction domain_bitToStr(domain) {\n  ASSERT_NUMDOM(domain);\n\n  if (domain === EMPTY) return EMPTY_STR;\n\n  let str = EMPTY_STR;\n  let lo = -1;\n  let hi = -1;\n\n  if ((1 << 0) & domain) {\n    lo = 0;\n    hi = 0;\n  }\n\n  if ((1 << 1) & domain) {\n    if (lo !== 0) {\n      // Lo is either 0 or nothing\n      lo = 1;\n    }\n\n    hi = 1; // There cannot be a gap yet\n  }\n\n  if ((1 << 2) & domain) {\n    if (hi === 0) {\n      str = domain_str_encodeRange(0, 0);\n      lo = 2;\n    } else if (hi !== 1) {\n      // If hi isnt 0 and hi isnt 1 then hi isnt set and so lo isnt set\n      lo = 2;\n    }\n\n    hi = 2;\n  }\n\n  if ((1 << 3) & domain) {\n    if (hi < 0) {\n      // This is the LSB that is set\n      lo = 3;\n    } else if (hi !== 2) {\n      // There's a gap so push prev range now\n      str += domain_str_encodeRange(lo, hi);\n      lo = 3;\n    }\n\n    hi = 3;\n  }\n\n  // Is the fifth bit or higher even set at all? for ~85% that is not the case at this point\n  if (domain >= 1 << 4) {\n    for (let i = 4; i <= SMALL_MAX_NUM; ++i) {\n      if (domain & (1 << i)) {\n        if (hi < 0) {\n          // This is the LSB that is set\n          lo = i;\n        } else if (hi !== i - 1) {\n          // There's a gap so push prev range now\n          str += domain_str_encodeRange(lo, hi);\n          lo = i;\n        }\n\n        hi = i;\n      }\n    }\n  }\n\n  // Since the domain wasn't empty (checked at start) there\n  // must now be an unpushed lo/hi pair left to push...\n  str += domain_str_encodeRange(lo, hi);\n\n  return str;\n}\n\nfunction domain_arrToStr(arrdom) {\n  ASSERT_ARRDOM(arrdom);\n\n  let str = EMPTY_STR;\n  for (let i = 0, len = arrdom.length; i < len; i += ARR_RANGE_SIZE) {\n    const lo = arrdom[i];\n    const hi = arrdom[i + 1];\n    ASSERT(typeof lo === 'number');\n    ASSERT(typeof hi === 'number');\n\n    str += domain_str_encodeRange(lo, hi);\n  }\n\n  return str;\n}\n\n/**\n * Returns the smallest representation of given domain. The order is:\n * soldom < numdom < strdom\n * Won't return arrdoms.\n *\n * @param {$domain} domain\n * @returns {$domain}\n */\nfunction domain_toSmallest(domain) {\n  if (typeof domain === 'number') return domain_numToSmallest(domain);\n  ASSERT(typeof domain === 'string', 'there is no arrtosmallest', domain);\n  return domain_strToSmallest(domain);\n}\n\nfunction domain_anyToSmallest(domain) {\n  // For tests and config import\n  if (Array.isArray(domain)) domain = domain_arrToStr(domain);\n  return domain_toSmallest(domain);\n}\n\nfunction domain_numToSmallest(domain) {\n  if (domain >= SOLVED_FLAG) return domain;\n  return domain_bitToSmallest(domain);\n}\n\nfunction domain_bitToSmallest(domain) {\n  const value = domain_getValue(domain);\n  if (value === NO_SUCH_VALUE) return domain;\n  return domain_createValue(value);\n}\n\nfunction domain_strToSmallest(domain) {\n  const len = domain.length;\n  if (!len) return EMPTY;\n  const min = domain_str_decodeValue(domain, 0);\n  const max = domain_str_decodeValue(domain, len - STR_VALUE_SIZE);\n  if (len === STR_RANGE_SIZE) {\n    if (min === max) return domain_createValue(min);\n  }\n\n  if (max <= SMALL_MAX_NUM) return domain_strToBit(domain, len);\n  return domain;\n}\n\n/**\n * Convert string domain to number domain. Assumes domain\n * is eligible to be a small domain.\n *\n * @param {$strdom} strdom\n * @param {number} len Cache of domain.length (string length... not value count)\n * @returns {$strdom}\n */\nfunction domain_strToBit(strdom, len) {\n  ASSERT_STRDOM(strdom);\n  ASSERT(strdom.length === len, 'len should be cache of domain.length');\n  ASSERT(\n    domain_max(strdom) <= SMALL_MAX_NUM,\n    'SHOULD_BE_SMALL_DOMAIN',\n    strdom,\n    domain_max(strdom)\n  );\n\n  if (len === 0) return EMPTY;\n\n  const lo = domain_str_decodeValue(strdom, 0);\n  const hi = domain_str_decodeValue(strdom, 0 + STR_VALUE_SIZE);\n\n  // If (len === STR_RANGE_SIZE && lo === hi) {\n  //  return (lo | SOLVED_FLAG) >>> 0; // >>>0 forces unsigned.\n  // }\n\n  let out = domain_bit_addRange(EMPTY, lo, hi);\n  for (let i = STR_RANGE_SIZE; i < len; i += STR_RANGE_SIZE) {\n    const lo = domain_str_decodeValue(strdom, i);\n    const hi = domain_str_decodeValue(strdom, i + STR_VALUE_SIZE);\n    out = domain_bit_addRange(out, lo, hi);\n  }\n\n  return out;\n}\n\nfunction domain_arrToSmallest(arrdom) {\n  ASSERT_ARRDOM(arrdom);\n\n  const len = arrdom.length;\n  if (len === 0) return EMPTY;\n  if (len === ARR_RANGE_SIZE && arrdom[0] === arrdom[1])\n    return domain_createValue(arrdom[0]);\n\n  ASSERT(typeof arrdom[arrdom.length - 1] === 'number');\n  const max = domain_arr_max(arrdom);\n  if (max <= SMALL_MAX_NUM) return _domain_arrToBit(arrdom, len);\n\n  return domain_arrToStr(arrdom);\n}\n\nfunction _domain_arrToBit(domain, len) {\n  ASSERT_ARRDOM(domain);\n  ASSERT(\n    domain[domain.length - 1] <= SMALL_MAX_NUM,\n    'SHOULD_BE_SMALL_DOMAIN',\n    domain\n  );\n\n  // TODO\n  // if (domain.length === 2 && domain[0] === domain[1]) return (domain[0] | SOLVED_FLAG) >>> 0;\n\n  let out = 0;\n  for (let i = 0; i < len; i += ARR_RANGE_SIZE) {\n    out = domain_bit_addRange(out, domain[i], domain[i + 1]);\n  }\n\n  return out;\n}\n\nexport {\n  ARR_FIRST_RANGE_HI,\n  ARR_FIRST_RANGE_LO,\n  EMPTY,\n  EMPTY_STR,\n  STR_FIRST_RANGE_HI,\n  STR_FIRST_RANGE_LO,\n  STR_RANGE_SIZE,\n  STR_VALUE_SIZE,\n  //domain_appendRange,\n  domain_arrToSmallest,\n  domain_str_closeGaps,\n  domain_containsValue,\n  domain_num_containsValue,\n  domain_createBoolyPair,\n  domain_createEmpty,\n  domain_createRange,\n  domain_createRangeTrimmed,\n  domain_numnum_createRangeZeroToMax,\n  domain_num_createRange,\n  domain_createValue,\n  domain__debug,\n  domain_divby,\n  domain_divByValue,\n  domain_fromListToArrdom,\n  domain_getFirstIntersectingValue,\n  domain_getValue,\n  domain_hasNoZero,\n  domain_hasZero,\n  domain_intersection,\n  domain_intersectionValue,\n  domain_invMul,\n  domain_invMulValue,\n  domain_isBool,\n  domain_isBooly,\n  domain_isBoolyPair,\n  domain_isEmpty,\n  domain_isSolved,\n  domain_isZero,\n  domain_max,\n  domain_middleElement,\n  domain_min,\n  domain_mul,\n  domain_mulByValue,\n  domain_numToStr,\n  domain_removeGte,\n  domain_removeGtUnsafe,\n  domain_removeLte,\n  domain_removeLtUnsafe,\n  domain_removeValue,\n  domain_resolveAsBooly,\n  domain_sharesNoElements,\n  domain_str_simplify,\n  domain_size,\n  domain_str_decodeValue,\n  domain_str_encodeRange,\n  domain_toArr,\n  domain_toSmallest,\n  domain_anyToSmallest,\n  domain_toList,\n  domain_toStr,\n  // Testing only:\n  domain_str_rangeIndexOf,\n  _domain_str_mergeOverlappingRanges,\n  _domain_str_quickSortRanges,\n};\n","// This file only concerns itself with adding two domains\n// The algorithm is conceptually simple but the support\n// for both array and numbered domains makes it a little\n// bloated. However, since it saves significant we do it\n// anyways.\n\n// Conceptually: range1+range2 = [lo1+lo2, hi1+hi2]\n// [5, 10] + [20, 30]\n// [5+20, 10+30] -> [25, 40]\n\nimport { SMALL_MAX_NUM, SOLVED_FLAG, SUP } from '../constants';\nimport { ASSERT, ASSERT_NUMDOM, ASSERT_NORDOM, ASSERT_STRDOM } from '../assert';\nimport {\n  EMPTY,\n  EMPTY_STR,\n  STR_RANGE_SIZE,\n  STR_VALUE_SIZE,\n  domain_str_closeGaps,\n  domain_num_createRange,\n  domain_str_decodeValue,\n  domain_str_encodeRange,\n  domain_max,\n  domain_str_simplify,\n  domain_toSmallest,\n} from './domain_lib';\n\nconst { min } = Math;\n\n/**\n * Does not harm input domains\n *\n * @param {$domain} domain1\n * @param {$domain} domain2\n * @returns {$domain}\n */\nfunction domain_plus(domain1, domain2) {\n  ASSERT_NORDOM(domain1);\n  ASSERT_NORDOM(domain2);\n\n  // Note: this is not 0+x=x. this is nothing+something=nothing because the domains contain no value\n  if (!domain1 || !domain2) return EMPTY;\n\n  const isNum1 = typeof domain1 === 'number';\n  const isNum2 = typeof domain2 === 'number';\n\n  let result;\n  if (isNum1 && isNum2) {\n    // If the highest number in the result is below the max of a small\n    // domain we can take a fast path for it. this case happens often.\n    if (_domain_plusWillBeSmall(domain1, domain2)) {\n      return domain_toSmallest(_domain_plusNumNumNum(domain1, domain2));\n    }\n\n    result = _domain_plusNumNumStr(domain1, domain2);\n  } else if (isNum1) result = _domain_plusNumStrStr(domain1, domain2);\n  else if (isNum2) result = _domain_plusNumStrStr(domain2, domain1);\n  // Swapped domains!\n  else result = _domain_plusStrStrStr(domain1, domain2);\n\n  return domain_toSmallest(domain_str_simplify(result));\n}\n\nfunction _domain_plusStrStrStr(domain1, domain2) {\n  ASSERT_STRDOM(domain1);\n  ASSERT_STRDOM(domain2);\n\n  // Simplify the domains by closing gaps since when we add\n  // the domains, the gaps will close according to the\n  // smallest interval width in the other domain.\n  const domains = domain_str_closeGaps(domain1, domain2);\n  domain1 = domains[0];\n  domain2 = domains[1];\n\n  let newDomain = EMPTY_STR;\n  for (\n    let index = 0, len = domain1.length;\n    index < len;\n    index += STR_RANGE_SIZE\n  ) {\n    const lo = domain_str_decodeValue(domain1, index);\n    const hi = domain_str_decodeValue(domain1, index + STR_VALUE_SIZE);\n    newDomain += _domain_plusRangeStrStr(lo, hi, domain2);\n  }\n\n  return newDomain;\n}\n\nfunction _domain_plusWillBeSmall(domain1, domain2) {\n  // If both domains are small enough they cannot add to a domain beyond the max\n  ASSERT(typeof domain1 === 'number', 'ONLY_WITH_NUMBERS');\n  ASSERT(typeof domain2 === 'number', 'ONLY_WITH_NUMBERS');\n\n  // If (((domain1 | domain2) >>> 0) < (1 << 15)) return true; // could catch some cases\n  // if (domain1 < (1<<15) && domain2 < (1<<15)) return true;  // alternative of above\n\n  return domain_max(domain1) + domain_max(domain2) <= SMALL_MAX_NUM; // If max changes, update above too!\n}\n\nfunction _domain_plusNumNumStr(domain1, domain2) {\n  ASSERT_NUMDOM(domain1);\n  ASSERT_NUMDOM(domain2);\n\n  if (domain1 >= SOLVED_FLAG) {\n    const solvedValue = domain1 ^ SOLVED_FLAG;\n    return _domain_plusRangeNumStr(solvedValue, solvedValue, domain2);\n  }\n\n  let flagIndex = 0;\n  // Find the first set bit. must find something because small domain and not empty\n  while ((domain1 & (1 << flagIndex)) === 0) ++flagIndex;\n\n  let lo = flagIndex;\n  let hi = flagIndex;\n\n  let flagValue = 1 << ++flagIndex;\n  let newDomain = EMPTY_STR;\n  while (flagValue <= domain1 && flagIndex <= SMALL_MAX_NUM) {\n    if ((flagValue & domain1) > 0) {\n      if (hi !== flagIndex - 1) {\n        // There's a gap so push prev range now\n        newDomain += _domain_plusRangeNumStr(lo, hi, domain2);\n        lo = flagIndex;\n      }\n\n      hi = flagIndex;\n    }\n\n    flagValue = 1 << ++flagIndex;\n  }\n\n  return newDomain + _domain_plusRangeNumStr(lo, hi, domain2);\n}\n\nfunction _domain_plusNumNumNum(domain1, domain2) {\n  ASSERT_NUMDOM(domain1);\n  ASSERT_NUMDOM(domain2);\n  ASSERT(domain1 !== EMPTY && domain2 !== EMPTY, 'SHOULD_BE_CHECKED_ELSEWHERE');\n  ASSERT(\n    domain_max(domain1) + domain_max(domain2) <= SMALL_MAX_NUM,\n    'THE_POINTE'\n  );\n\n  if (domain1 >= SOLVED_FLAG) {\n    const solvedValue = domain1 ^ SOLVED_FLAG;\n    return _domain_plusRangeNumNum(solvedValue, solvedValue, domain2);\n  }\n\n  let flagIndex = 0;\n  // Find the first set bit. must find something because small domain and not empty\n  while ((domain1 & (1 << flagIndex)) === 0) ++flagIndex;\n\n  let lo = flagIndex;\n  let hi = flagIndex;\n\n  let flagValue = 1 << ++flagIndex;\n\n  let newDomain = EMPTY;\n  while (flagValue <= domain1 && flagIndex <= SMALL_MAX_NUM) {\n    if ((flagValue & domain1) > 0) {\n      if (hi !== flagIndex - 1) {\n        // There's a gap so push prev range now\n        newDomain |= _domain_plusRangeNumNum(lo, hi, domain2);\n        lo = flagIndex;\n      }\n\n      hi = flagIndex;\n    }\n\n    flagValue = 1 << ++flagIndex;\n  }\n\n  return newDomain | _domain_plusRangeNumNum(lo, hi, domain2);\n}\n\nfunction _domain_plusRangeNumNum(loi, hii, domain_num) {\n  ASSERT_NUMDOM(domain_num);\n  ASSERT(domain_num !== EMPTY, 'SHOULD_BE_CHECKED_ELSEWHERE');\n\n  if (domain_num >= SOLVED_FLAG) {\n    const solvedValue = domain_num ^ SOLVED_FLAG;\n    return _domain_plusRangeRangeNum(loi, hii, solvedValue, solvedValue);\n  }\n\n  let flagIndex = 0;\n  // Find the first set bit. must find something because small domain and not empty\n  while ((domain_num & (1 << flagIndex)) === 0) ++flagIndex;\n\n  let lo = flagIndex;\n  let hi = flagIndex;\n\n  let flagValue = 1 << ++flagIndex;\n\n  let newDomain = EMPTY;\n  while (flagValue <= domain_num && flagIndex <= SMALL_MAX_NUM) {\n    if ((flagValue & domain_num) > 0) {\n      if (hi !== flagIndex - 1) {\n        // There's a gap so push prev range now\n        newDomain |= _domain_plusRangeRangeNum(loi, hii, lo, hi);\n        lo = flagIndex;\n      }\n\n      hi = flagIndex;\n    }\n\n    flagValue = 1 << ++flagIndex;\n  }\n\n  return newDomain | _domain_plusRangeRangeNum(loi, hii, lo, hi);\n}\n\nfunction _domain_plusNumStrStr(domain_num, domain_str) {\n  ASSERT_NUMDOM(domain_num);\n  ASSERT_STRDOM(domain_str);\n\n  if (domain_num >= SOLVED_FLAG) {\n    const solvedValue = domain_num ^ SOLVED_FLAG;\n    return _domain_plusRangeStrStr(solvedValue, solvedValue, domain_str);\n  }\n\n  let flagIndex = 0;\n  // Find the first set bit. must find something because small domain and not empty\n  while ((domain_num & (1 << flagIndex)) === 0) ++flagIndex;\n\n  let lo = flagIndex;\n  let hi = flagIndex;\n\n  let flagValue = 1 << ++flagIndex;\n\n  let newDomain = EMPTY_STR;\n  while (flagValue <= domain_num && flagIndex <= SMALL_MAX_NUM) {\n    if ((flagValue & domain_num) > 0) {\n      if (hi !== flagIndex - 1) {\n        // There's a gap so push prev range now\n        newDomain += _domain_plusRangeStrStr(lo, hi, domain_str);\n        lo = flagIndex;\n      }\n\n      hi = flagIndex;\n    }\n\n    flagValue = 1 << ++flagIndex;\n  }\n\n  return newDomain + _domain_plusRangeStrStr(lo, hi, domain_str);\n}\n\nfunction _domain_plusRangeNumStr(loi, hii, domain_num) {\n  ASSERT_NUMDOM(domain_num);\n\n  if (domain_num >= SOLVED_FLAG) {\n    const solvedValue = domain_num ^ SOLVED_FLAG;\n    return _domain_plusRangeRangeStr(loi, hii, solvedValue, solvedValue);\n  }\n\n  let flagIndex = 0;\n  // Find the first set bit. must find something because small domain and not empty\n  while ((domain_num & (1 << flagIndex)) === 0) ++flagIndex;\n\n  let lo = flagIndex;\n  let hi = flagIndex;\n\n  let flagValue = 1 << ++flagIndex;\n\n  let newDomain = EMPTY_STR;\n  while (flagValue <= domain_num && flagIndex <= SMALL_MAX_NUM) {\n    if ((flagValue & domain_num) > 0) {\n      if (hi !== flagIndex - 1) {\n        // There's a gap so push prev range now\n        newDomain += _domain_plusRangeRangeStr(loi, hii, lo, hi);\n        lo = flagIndex;\n      }\n\n      hi = flagIndex;\n    }\n\n    flagValue = 1 << ++flagIndex;\n  }\n\n  return newDomain + _domain_plusRangeRangeStr(loi, hii, lo, hi);\n}\n\nfunction _domain_plusRangeStrStr(loi, hii, domain_str) {\n  ASSERT_STRDOM(domain_str);\n\n  let newDomain = EMPTY_STR;\n  for (\n    let index = 0, len = domain_str.length;\n    index < len;\n    index += STR_RANGE_SIZE\n  ) {\n    const lo = domain_str_decodeValue(domain_str, index);\n    const hi = domain_str_decodeValue(domain_str, index + STR_VALUE_SIZE);\n    newDomain += _domain_plusRangeRangeStr(loi, hii, lo, hi);\n  }\n\n  return newDomain;\n}\n\nfunction _domain_plusRangeRangeStr(loi, hii, loj, hij) {\n  ASSERT(loi + loj >= 0, 'DOMAINS_SHOULD_NOT_HAVE_NEGATIVES');\n  const lo = loi + loj;\n  if (lo <= SUP) {\n    // If lo exceeds SUP the resulting range is completely OOB and we ignore it.\n    const hi = min(SUP, hii + hij);\n    return domain_str_encodeRange(lo, hi);\n  }\n\n  return EMPTY_STR;\n}\n\nfunction _domain_plusRangeRangeNum(loi, hii, loj, hij) {\n  ASSERT(loi + loj >= 0, 'DOMAINS_SHOULD_NOT_HAVE_NEGATIVES');\n  ASSERT(loi + loj <= SMALL_MAX_NUM, 'RESULT_SHOULD_NOT_EXCEED_SMALL_DOMAIN');\n  ASSERT(hii + hij <= SMALL_MAX_NUM, 'RESULT_SHOULD_NOT_EXCEED_SMALL_DOMAIN');\n\n  const domain = domain_num_createRange(loi + loj, hii + hij);\n  ASSERT(\n    typeof domain === 'number' && domain < SOLVED_FLAG,\n    'expecting numdom, not soldom'\n  );\n  return domain;\n}\n\nexport { domain_plus };\n","// This file only concerns itself with subtracting two domains\n// The algorithm is conceptually simple but the support\n// for both array and numbered domains makes it a little\n// bloated. However, since it saves significant we do it\n// anyways.\n\n// Conceptually: range1-range2 = [max(0, lo1-hi2), max(0, hi1-lo2)]\n// [5, 10] - [20, 30]\n// [5-30, 30-5] -> [-25, 25] --> [0, 25]\n\n// optimization shortcut: if both domains contain a zero the result\n// is [0, max(domain1)] because we drop negative numbers;\n// [lo1 - hi2, hi1 - lo2] -> [0 - hi2, hi1 - 0] -> [0, hi1]\n\n// a big table of all input/output for small domains can be found at\n// https://gist.github.com/qfox/fce6912ef17503b1055aac28fa34e8d1 (view\n// with text editor that doesn't wrap). Spoiler: it doesn't help :)\n\nimport { SMALL_MAX_NUM, SOLVED_FLAG, SUB } from '../constants';\nimport { ASSERT, ASSERT_NUMDOM, ASSERT_STRDOM, ASSERT_NORDOM } from '../assert';\nimport {\n  EMPTY,\n  EMPTY_STR,\n  STR_VALUE_SIZE,\n  STR_RANGE_SIZE,\n  domain_createRange,\n  domain_num_createRange,\n  domain_numnum_createRangeZeroToMax,\n  domain_createValue,\n  domain_str_closeGaps,\n  domain_num_containsValue,\n  domain_str_decodeValue,\n  domain_str_encodeRange,\n  domain_max,\n  domain_min,\n  domain_str_simplify,\n  domain_toSmallest,\n} from './domain_lib';\n\nconst { max } = Math;\n\n/**\n * Subtract one domain from the other\n *\n * @param {$domain} domain1\n * @param {$domain} domain2\n * @returns {$domain}\n */\nfunction domain_minus(domain1, domain2) {\n  ASSERT_NORDOM(domain1);\n  ASSERT_NORDOM(domain2);\n\n  // Note: this is not x-0=x. this is nothing-something=nothing because the domains contain no value\n  if (!domain1 || !domain2) return EMPTY;\n\n  // Optimize an easy path: if both domains contain zero the\n  // result will always be [0, max(domain1)], because:\n  // d1-d2 = [lo1-hi2, hi1-lo2] -> [0-hi2, hi1-0] -> [0, hi1]\n  if (domain_min(domain1) === 0 && domain_min(domain2) === 0) {\n    return domain_createRange(0, domain_max(domain1));\n  }\n\n  const isNum1 = typeof domain1 === 'number';\n  const isNum2 = typeof domain2 === 'number';\n  if (isNum1) {\n    // Note: if domain1 is a small domain the result is always a small domain\n    if (isNum2) return domain_toSmallest(_domain_minusNumNum(domain1, domain2));\n    const D = domain_toSmallest(_domain_minusNumStr(domain1, domain2));\n    if (D === EMPTY_STR) return EMPTY;\n    return D;\n  }\n\n  let result;\n  if (isNum2) result = _domain_minusStrNumStr(domain1, domain2);\n  // Cannot swap minus args!\n  else result = _domain_minusStrStrStr(domain1, domain2);\n\n  const E = domain_toSmallest(domain_str_simplify(result));\n  if (E === EMPTY_STR) return EMPTY;\n  return E;\n}\n\nfunction _domain_minusStrStrStr(domain1, domain2) {\n  ASSERT_STRDOM(domain1);\n  ASSERT_STRDOM(domain2);\n\n  // Simplify the domains by closing gaps since when we add\n  // the domains, the gaps will close according to the\n  // smallest interval width in the other domain.\n  const domains = domain_str_closeGaps(domain1, domain2);\n  domain1 = domains[0];\n  domain2 = domains[1];\n  ASSERT(typeof domain1 === 'string', 'make sure closeGaps doesnt \"optimize\"');\n  ASSERT(typeof domain2 === 'string', 'make sure closeGaps doesnt \"optimize\"');\n\n  let newDomain = EMPTY_STR;\n  for (\n    let index = 0, len = domain1.length;\n    index < len;\n    index += STR_RANGE_SIZE\n  ) {\n    const lo = domain_str_decodeValue(domain1, index);\n    const hi = domain_str_decodeValue(domain1, index + STR_VALUE_SIZE);\n    newDomain += _domain_minusRangeStrStr(lo, hi, domain2);\n  }\n\n  return newDomain;\n}\n\nfunction _domain_minusNumNum(domain1, domain2) {\n  if (domain1 >= SOLVED_FLAG) {\n    const solvedValue = domain1 ^ SOLVED_FLAG;\n    if (domain2 >= SOLVED_FLAG) {\n      const result = solvedValue - (domain2 ^ SOLVED_FLAG);\n      if (result < 0) return EMPTY;\n      return domain_createValue(result);\n    }\n\n    if (solvedValue <= SMALL_MAX_NUM)\n      return _domain_minusRangeNumNum(solvedValue, solvedValue, domain2);\n    return _domain_minusRangeNumStr(solvedValue, solvedValue, domain2);\n  }\n\n  return _domain_minusNumNumNum(domain1, domain2);\n}\n\nfunction _domain_minusNumNumNum(domain1, domain2) {\n  ASSERT_NUMDOM(domain1);\n  ASSERT_NUMDOM(domain2);\n  ASSERT(domain1 !== EMPTY && domain2 !== EMPTY, 'SHOULD_BE_CHECKED_ELSEWHERE');\n  ASSERT(\n    domain_max(domain1) - domain_min(domain2) <= SMALL_MAX_NUM,\n    'MAX-MIN_MUST_NOT_EXCEED_NUMDOM_RANGE'\n  );\n  ASSERT(\n    domain1 < SOLVED_FLAG,\n    'solved domain1 is expected to be caught elsewhere'\n  );\n\n  if (\n    domain_num_containsValue(domain1, 0) &&\n    domain_num_containsValue(domain2, 0)\n  )\n    return domain_numnum_createRangeZeroToMax(domain1);\n\n  let flagIndex = 0;\n  // Find the first set bit. must find something because small domain and not empty\n  while ((domain1 & (1 << flagIndex)) === 0) ++flagIndex;\n\n  let lo = flagIndex;\n  let hi = flagIndex;\n\n  let flagValue = 1 << ++flagIndex;\n\n  let newDomain = EMPTY;\n  while (flagValue <= domain1 && flagIndex <= SMALL_MAX_NUM) {\n    if ((flagValue & domain1) > 0) {\n      if (hi !== flagIndex - 1) {\n        // There's a gap so push prev range now\n        newDomain |= _domain_minusRangeNumNum(lo, hi, domain2);\n        lo = flagIndex;\n      }\n\n      hi = flagIndex;\n    }\n\n    flagValue = 1 << ++flagIndex;\n  }\n\n  return newDomain | _domain_minusRangeNumNum(lo, hi, domain2);\n}\n\nfunction _domain_minusNumStr(domain_num, domain_str) {\n  if (domain_num >= SOLVED_FLAG) {\n    const solvedValue = domain_num ^ SOLVED_FLAG;\n    if (solvedValue <= SMALL_MAX_NUM)\n      return _domain_minusRangeStrNum(solvedValue, solvedValue, domain_str);\n    return _domain_minusRangeStrStr(solvedValue, solvedValue, domain_str);\n  }\n\n  return _domain_minusNumStrNum(domain_num, domain_str);\n}\n\nfunction _domain_minusNumStrNum(domain_num, domain_str) {\n  ASSERT_NUMDOM(domain_num);\n  ASSERT_STRDOM(domain_str);\n  ASSERT(\n    domain_num !== EMPTY && domain_str !== EMPTY,\n    'SHOULD_BE_CHECKED_ELSEWHERE'\n  );\n  ASSERT(\n    domain_max(domain_num) - domain_min(domain_str) <= SMALL_MAX_NUM,\n    'MAX-MIN_MUST_NOT_EXCEED_NUMDOM_RANGE'\n  );\n\n  if (domain_num >= SOLVED_FLAG) {\n    const solvedValue = domain_num ^ SOLVED_FLAG;\n    return _domain_minusRangeStrNum(solvedValue, solvedValue, domain_str);\n  }\n\n  // Since any number above the small domain max ends up with negative, which is truncated, use the max of domain1\n  if (domain_num_containsValue(domain_num, 0) && domain_min(domain_str) === 0)\n    return domain_numnum_createRangeZeroToMax(domain_num);\n\n  let flagIndex = 0;\n  // Find the first set bit. must find something because small domain and not empty\n  while ((domain_num & (1 << flagIndex)) === 0) ++flagIndex;\n\n  let lo = flagIndex;\n  let hi = flagIndex;\n\n  let flagValue = 1 << ++flagIndex;\n\n  let newDomain = EMPTY;\n  while (flagValue <= domain_num && flagIndex <= SMALL_MAX_NUM) {\n    if ((flagValue & domain_num) > 0) {\n      if (hi !== flagIndex - 1) {\n        // There's a gap so push prev range now\n        newDomain |= _domain_minusRangeStrNum(lo, hi, domain_str);\n        lo = flagIndex;\n      }\n\n      hi = flagIndex;\n    }\n\n    flagValue = 1 << ++flagIndex;\n  }\n\n  return newDomain | _domain_minusRangeStrNum(lo, hi, domain_str);\n}\n\nfunction _domain_minusRangeNumNum(loi, hii, domain_num) {\n  ASSERT_NUMDOM(domain_num);\n  ASSERT(domain_num !== EMPTY, 'SHOULD_BE_CHECKED_ELSEWHERE');\n\n  if (domain_num >= SOLVED_FLAG) {\n    const solvedValue = domain_num ^ SOLVED_FLAG;\n    return _domain_minusRangeRangeNum(loi, hii, solvedValue, solvedValue);\n  }\n\n  let flagIndex = 0;\n  // Find the first set bit. must find something because small domain and not empty\n  while ((domain_num & (1 << flagIndex)) === 0) ++flagIndex;\n\n  let lo = flagIndex;\n  let hi = flagIndex;\n\n  let flagValue = 1 << ++flagIndex;\n\n  let newDomain = EMPTY;\n  while (flagValue <= domain_num && flagIndex <= SMALL_MAX_NUM) {\n    if ((flagValue & domain_num) > 0) {\n      if (hi !== flagIndex - 1) {\n        // There's a gap so push prev range now\n        newDomain |= _domain_minusRangeRangeNum(loi, hii, lo, hi);\n        lo = flagIndex;\n      }\n\n      hi = flagIndex;\n    }\n\n    flagValue = 1 << ++flagIndex;\n  }\n\n  return newDomain | _domain_minusRangeRangeNum(loi, hii, lo, hi);\n}\n\nfunction _domain_minusStrNumStr(domain_str, domain_num) {\n  ASSERT_NUMDOM(domain_num);\n  ASSERT_STRDOM(domain_str);\n  ASSERT(\n    domain_num !== EMPTY && domain_str !== EMPTY,\n    'SHOULD_BE_CHECKED_ELSEWHERE'\n  );\n\n  // Optimize an easy path: if both domains contain zero the\n  // result will always be [0, max(domain1)], because:\n  // d1-d2 = [lo1-hi2, hi1-lo2] -> [0-hi2, hi1-0] -> [0, hi1]\n  if (domain_min(domain_str) === 0 && domain_min(domain_num) === 0) {\n    return domain_createRange(0, domain_max(domain_str));\n  }\n\n  let newDomain = EMPTY_STR;\n  for (\n    let index = 0, len = domain_str.length;\n    index < len;\n    index += STR_RANGE_SIZE\n  ) {\n    const lo = domain_str_decodeValue(domain_str, index);\n    const hi = domain_str_decodeValue(domain_str, index + STR_VALUE_SIZE);\n    newDomain += _domain_minusRangeNumStr(lo, hi, domain_num);\n  }\n\n  return newDomain;\n}\n\nfunction _domain_minusRangeNumStr(loi, hii, domain_num) {\n  ASSERT_NUMDOM(domain_num);\n\n  if (domain_num === EMPTY) return EMPTY;\n\n  if (domain_num >= SOLVED_FLAG) {\n    const solvedValue = domain_num ^ SOLVED_FLAG;\n    return _domain_minusRangeRangeStr(loi, hii, solvedValue, solvedValue);\n  }\n\n  let flagIndex = 0;\n  // Find the first set bit. must find something because small domain and not empty\n  while ((domain_num & (1 << flagIndex)) === 0) ++flagIndex;\n\n  let lo = flagIndex;\n  let hi = flagIndex;\n\n  let flagValue = 1 << ++flagIndex;\n  let newDomain = EMPTY_STR;\n  while (flagValue <= domain_num && flagIndex <= SMALL_MAX_NUM) {\n    if ((flagValue & domain_num) > 0) {\n      if (hi !== flagIndex - 1) {\n        // There's a gap so push prev range now\n        newDomain += _domain_minusRangeRangeStr(loi, hii, lo, hi);\n        lo = flagIndex;\n      }\n\n      hi = flagIndex;\n    }\n\n    flagValue = 1 << ++flagIndex;\n  }\n\n  return newDomain + _domain_minusRangeRangeStr(loi, hii, lo, hi);\n}\n\nfunction _domain_minusRangeStrStr(loi, hii, domain_str) {\n  ASSERT_STRDOM(domain_str);\n\n  let newDomain = EMPTY_STR;\n  for (\n    let index = 0, len = domain_str.length;\n    index < len;\n    index += STR_RANGE_SIZE\n  ) {\n    const lo = domain_str_decodeValue(domain_str, index);\n    const hi = domain_str_decodeValue(domain_str, index + STR_VALUE_SIZE);\n    newDomain += _domain_minusRangeRangeStr(loi, hii, lo, hi);\n  }\n\n  return newDomain;\n}\n\nfunction _domain_minusRangeStrNum(loi, hii, domain_str) {\n  ASSERT_STRDOM(domain_str);\n\n  let newDomain = EMPTY;\n  for (\n    let index = 0, len = domain_str.length;\n    index < len;\n    index += STR_RANGE_SIZE\n  ) {\n    const lo = domain_str_decodeValue(domain_str, index);\n    const hi = domain_str_decodeValue(domain_str, index + STR_VALUE_SIZE);\n    newDomain |= _domain_minusRangeRangeNum(loi, hii, lo, hi);\n  }\n\n  return newDomain;\n}\n\nfunction _domain_minusRangeRangeStr(loi, hii, loj, hij) {\n  const hi = hii - loj;\n  if (hi >= SUB) {\n    // Silently ignore results that are OOB\n    const lo = max(SUB, loi - hij);\n    return domain_str_encodeRange(lo, hi);\n  }\n\n  return EMPTY_STR;\n}\n\nfunction _domain_minusRangeRangeNum(loi, hii, loj, hij) {\n  const hi = hii - loj;\n  if (hi >= SUB) {\n    // Silently ignore results that are OOB\n    const lo = max(SUB, loi - hij);\n    ASSERT(lo <= SMALL_MAX_NUM, 'RESULT_SHOULD_NOT_EXCEED_SMALL_DOMAIN');\n    ASSERT(hi <= SMALL_MAX_NUM, 'RESULT_SHOULD_NOT_EXCEED_SMALL_DOMAIN');\n    const domain = domain_num_createRange(lo, hi);\n    ASSERT(\n      typeof domain === 'number' && domain < SOLVED_FLAG,\n      'expecting numdom, not soldom'\n    );\n    return domain;\n  }\n\n  return EMPTY;\n}\n\nexport { domain_minus };\n","// NOTE: THIS IS NOT A GENERIC TRIE IMPLEMENTATION\n// It's specifically geared towards the use within fdq\n// Input strings are assumed to be limited to ascii 32-132\n\nimport { THROW } from './helpers';\nimport { ASSERT } from './assert';\n\nconst TRIE_ROOT_OFFSET = 0;\nconst TRIE_BUCKET_COUNT = 10; // 10 digits\nconst TRIE_NODE_SIZE = TRIE_BUCKET_COUNT + 1; // Inc value\n\nconst TRIE_INITIAL_SIZE = 16 * 1024;\nconst TRIE_MINIMAL_GROWTH = 4 * 1024;\n\nconst TRIE_KEY_NOT_FOUND = -1;\n\nconst TRIE_EMPTY = undefined;\nconst TRIE_DEFAULT_SIZE = undefined;\nconst TRIE_8_BIT = 8;\nconst TRIE_16_BIT = 16;\nconst TRIE_32_BIT = 32;\nconst TRIE_64_BIT = 64;\nconst TRIE_DEFAULT_BITS = undefined;\n\n// Every trie node needs space for 10 jumps + 1 leaf value (must be capable of containing\n// `size(Trie)-1`) so initially 11 bytes, later 12 bytes and then 22 bytes once the number of\n// nodes exceeds 255\n\n/**\n * Create a new trie and, optionally, initialize it\n * with given values as keys and their index as value.\n * Check `trie_add` for assumed key composition restrictions\n *\n * @param {string[]} [valuesByIndex] If exists, adds all values in array as keys, index as values\n * @param {number} [initialLength] Hint to help control memory consumption for large/small tries. This length is in cells, not bytes. (byteLength=length*(bitsize/8))\n * @param {number} [initialBitsize] Hint to set bitsize explicitly. One of: 8 16 32 64\n * @returns {$trie}\n */\nfunction trie_create(valuesByIndex, initialLength, initialBitsize) {\n  const size = initialLength | 0 || TRIE_INITIAL_SIZE;\n  // TODO: if (!size) THROW('fixme'); // Blabla it's possible the constant is not yet initialized due to minification. dont initialize a trie in module global space\n  const bits = Math.max(trie_getValueBitsize(size), initialBitsize | 0); // Given bitsize might be lower than max address, ignore it in that case\n  const buffer = trie_createBuffer(size, bits);\n\n  // Have to use a wrapper because the buffer ref may change when it grows\n  // otherwise we could just store the meta data inside the buffer. but at\n  // least this is easier to read :)\n  let trie = {\n    _class: '$trie',\n    buffer,\n    bits, // 8 16 32 (64?)\n    lastNode: TRIE_ROOT_OFFSET, // Pointer to last node in the buffer\n    count: 0, // Number of keys in the Trie\n  };\n\n  if (process.env.NODE_ENV !== 'production') {\n    trie = {\n      ...trie,\n      // Debug stats... any use should be wrapped in ASSERT so that it's use gets removed in a dist\n      _mallocs: String(buffer.length), // Malloc steps in a string\n      _adds: 0, // Number of trie_add calls\n      _addSteps: 0, // Sum of steps taken in all trie_add calls\n      _hass: 0, // Number of trie_has calls\n      _gets: 0, // Number of trie_get calls (and also contains has)\n      _getSteps: 0, // Sum of steps for all gets on this trie\n    };\n  }\n\n  if (valuesByIndex) {\n    for (let i = 0, n = valuesByIndex.length; i < n; ++i) {\n      trie_add(trie, valuesByIndex[i], i);\n    }\n  }\n\n  return trie;\n}\n\n/**\n * Create a buffer\n *\n * @param {number} size Length of the buffer in cells, not bytes (!)\n * @param {number} bits One of: 8 16 32 64\n * @returns {TypedArray}\n */\nfunction trie_createBuffer(size, bits) {\n  switch (bits) {\n    case TRIE_8_BIT:\n      return new Uint8Array(size);\n    case TRIE_16_BIT:\n      return new Uint16Array(size);\n    case TRIE_32_BIT:\n      return new Uint32Array(size);\n    case TRIE_64_BIT:\n      return new Float64Array(size); // Let's hope not ;)\n    default:\n      THROW('Unsupported bit size');\n  }\n}\n\n/**\n * Reserve a part of the Trie memory to represent a node in the Trie.\n *\n * In this particular implementation nodes are of fixed width. It's\n * a field of 10 address cells and one value cell.\n *\n * Address cells point to other nodes. If zero, there is none (because\n * that would be the root node) and a search ends in not found.\n *\n * Value cells that are zero (default) are also \"not found\".\n *\n * @returns {Uint16Array}\n */\nfunction trie_addNode(trie) {\n  const newNodePtr = trie.lastNode + TRIE_NODE_SIZE;\n  trie.lastNode = newNodePtr;\n  // Technically the `while` is valid (instead of an `if`) but only\n  // if the buffer could grow by a smaller amount than the node size...\n  // note: buffer.length is cell size, buffer.byteLength is byte size. we want cells here.\n  while (newNodePtr + TRIE_NODE_SIZE >= trie.buffer.length) trie_grow(trie);\n  return newNodePtr;\n}\n\n/**\n * Allocate more size for this Trie\n *\n * Basically creates a new buffer with a larger size and then copies\n * the current buffer into it. If the new size exceeds the max size\n * of the current type (16bit/32bit) then the buffer is converted to\n * a bigger bit size automagically.\n * The trie buffer reference will be updated with the new buffer\n *\n * @param {$trie} trie\n */\nfunction trie_grow(trie) {\n  const len = trie.buffer.length; // Cell size! not byte size.\n  let newSize = ~~(len * 1.1); // Grow by 10% (an arbitrary number)\n  if (len + TRIE_MINIMAL_GROWTH > newSize) newSize = TRIE_MINIMAL_GROWTH + len;\n\n  trie_malloc(trie, newSize);\n}\n\n/**\n * Allocate space for a Trie and copy given Trie to it.\n * Will grow bitsize if required, but never shrink it.\n * (Bitsize must grow if cell size exceeds certain threshholds\n * because otherwise we can't address all bytes in the buffer)\n *\n * @param {$trie} trie\n * @param {number} size Cell size, not byte size\n */\nfunction trie_malloc(trie, size) {\n  // Make sure addressing fits\n  const newBits = trie_getValueBitsize(size);\n\n  // Dont shrink bit size even if length would allow it; \"large\" _values_ may require it\n  // (our tries dont need to shrink)\n  trie.bits = Math.max(trie.bits, newBits);\n\n  const nbuf = trie_createBuffer(size, trie.bits);\n  nbuf.set(trie.buffer, 0);\n  if (process.env.NODE_ENV !== 'production')\n    ASSERT((trie._mallocs += ' ' + nbuf.length));\n  trie.buffer = nbuf;\n}\n\n/**\n * Return the cell width in bits to fit given value.\n * For example, numbers below 256 can be represented in\n * 8 bits but numbers above it will need at least 16 bits.\n * Max is 64 but you can't pass on larger numbers in JS, anyways :)\n *\n * @param {number} value\n * @returns {number}\n */\nfunction trie_getValueBitsize(value) {\n  if (value < 0x100) return TRIE_8_BIT;\n  if (value < 0x10000) return TRIE_16_BIT;\n  if (value < 0x100000000) return TRIE_32_BIT;\n  return TRIE_64_BIT;\n}\n\n/**\n * Add a key/value pair\n *\n * Note: keys and values are of limited structure\n *\n * The key must be a string of ascii in range of 32-131.\n * This key is hashed by turning each character into its\n * ascii ordinal value, stringifying it padded with zero,\n * and hashing each of the two resulting digits. This way\n * we can guarantee that each node in the Trie only\n * requires 10 places (one for each digit) plus a value.\n * That makes reads super fast.\n *\n * @param {$trie} trie\n * @param {string} key\n * @param {number} value Any unsigned 32bit-1 value\n * @returns {number} previous value, or -1 if there wasn't any\n */\nfunction trie_add(trie, key, value) {\n  if (process.env.NODE_ENV !== 'production') ASSERT(++trie._adds);\n  trie_ensureValueFits(trie, value);\n  return _trie_add(trie, TRIE_ROOT_OFFSET, key, 0, key.length, value);\n}\n\n/**\n * Recursively find the place to add the key. If\n * the trail runs cold, pave it. Clobbers existing\n * values (though in our implementation that current\n * shouldn't really happen...)\n *\n * @param {$trie} trie\n * @param {number} offset\n * @param {string} key\n * @param {number} index Current index of the key being walked\n * @param {number} len Cache of key.length\n * @param {number} value Any unsigned 32bit-1 value\n * @returns {number} the old value, or not found\n */\nfunction _trie_add(trie, offset, key, index, len, value) {\n  if (process.env.NODE_ENV !== 'production') ASSERT(++trie._addSteps);\n\n  ASSERT(offset >= 0, 'OFFSET_UNSIGNED');\n  ASSERT(typeof key === 'string', 'STRING_KEY');\n  ASSERT(index >= 0, 'INDEX_UNSIGNED');\n  ASSERT(key.length === len, 'KEY_LEN');\n  ASSERT(value >= 0, 'VALUE_UNSIGNED');\n\n  // Dont create next path part if it would create a leaf node\n  if (index >= len) {\n    const { buffer } = trie;\n    const valuePtr = offset + TRIE_BUCKET_COUNT;\n    const curValue = trie.buffer[valuePtr];\n    if (!curValue) ++trie.count;\n    buffer[valuePtr] = value + 1; // 0 is reserved to mean \"unused\"\n    return curValue - 1;\n  }\n\n  const c = key.charCodeAt(index) - 32; // Allow all asciis 31 < c < 130 encoded as stringified double digits\n\n  offset = _trie_pavePath(trie, offset, c % 10);\n  offset = _trie_pavePath(trie, offset, Math.floor(c / 10));\n\n  return _trie_add(trie, offset, key, index + 1, len, value);\n}\n\n/**\n * Add a key/value pair\n *\n * This adds a value under a key that is a number. This\n * way reads and writes take `ceil(log(n)/log(10))` steps.\n * Eg. as many steps as digits in the decimal number.\n *\n * @param {$trie} trie\n * @param {number} key Assumes an unsigned int\n * @param {number} value Any unsigned 32bit-1 value\n * @returns {number} previous value, or -1 if there wasn't any\n */\nfunction trie_addNum(trie, key, value) {\n  if (process.env.NODE_ENV !== 'production') ASSERT(++trie._adds);\n  trie_ensureValueFits(trie, value);\n  return _trie_addNum(trie, TRIE_ROOT_OFFSET, key + 1, value);\n}\n\n/**\n * Recursively find the place to add the key. If\n * the trail runs cold, pave it. Clobbers existing\n * values (though in our implementation that current\n * shouldn't really happen...)\n *\n * @param {$trie} trie\n * @param {number} offset\n * @param {number} key Assumes an unsigned int >0\n * @param {number} value Any unsigned 32bit-1 value\n * @returns {number} the old value, or not found\n */\nfunction _trie_addNum(trie, offset, key, value) {\n  if (process.env.NODE_ENV !== 'production') ASSERT(++trie._addSteps);\n\n  ASSERT(offset >= 0, 'OFFSET_UNSIGNED');\n  ASSERT(typeof key === 'number', 'NUMBER_KEY');\n  ASSERT(value >= 0, 'VALUE_UNSIGNED');\n\n  if (key === 0) {\n    const { buffer } = trie;\n    const valuePtr = offset + TRIE_BUCKET_COUNT;\n    const curValue = trie.buffer[valuePtr];\n    if (!curValue) ++trie.count;\n    buffer[valuePtr] = value + 1; // 0 is reserved to mean \"unused\"\n    return curValue - 1;\n  }\n\n  offset = _trie_pavePath(trie, offset, key % 10);\n  key = Math.floor(key / 10);\n\n  return _trie_addNum(trie, offset, key, value);\n}\n\n/**\n * Make sure the Trie can hold a value of given manitude.\n * If the current bitsize of the trie is too small it will\n * grow the buffer to accomodate the larger size.\n *\n * @param {$trie} trie\n * @param {number} value\n */\nfunction trie_ensureValueFits(trie, value) {\n  const bitsNeeded = trie_getValueBitsize(value);\n  if (bitsNeeded > trie.bits) {\n    trie.bits = bitsNeeded;\n    trie_malloc(trie, trie.buffer.length); // Note: length = cell size, byteLength = byte size. we mean cell here.\n  }\n}\n\n/**\n * One step of writing a value. Offset should be a node, if\n * the digit has no address yet create it. If a node needs\n * to be created the buffer may be grown to fit the new node.\n * It will return the pointer of the (possibly new) next\n * node for given digit.\n *\n * @param {$trie} trie\n * @param {number} offset Start of a node\n * @param {number} digit Zero through nine\n * @returns {number} new address\n */\nfunction _trie_pavePath(trie, offset, digit) {\n  offset += digit;\n  let ptr = trie.buffer[offset];\n  if (!ptr) {\n    ptr = trie_addNode(trie);\n    trie.buffer[offset] = ptr;\n  }\n\n  return ptr;\n}\n\n/**\n * Find the value for given key. See trie_add for more details.\n *\n * @param {$trie} trie\n * @param {string} key\n * @returns {number} -1 if not found, >= 0 otherwise\n */\nfunction trie_get(trie, key) {\n  if (process.env.NODE_ENV !== 'production') ASSERT(++trie._gets);\n  return _trie_get(trie, TRIE_ROOT_OFFSET, key, 0, key.length);\n}\n\n/**\n * Recursive function to search for key\n *\n * @param {$trie} trie\n * @param {number} offset Start of a node\n * @param {string} key\n * @param {number} index Current index of the key being walked\n * @param {number} len Cache of key.length\n * @returns {number} -1 if not found or >= 0 otherwise\n */\nfunction _trie_get(trie, offset, key, index, len) {\n  if (process.env.NODE_ENV !== 'production') ASSERT(++trie._getSteps);\n\n  ASSERT(offset >= 0, 'OFFSET_UNSIGNED');\n  ASSERT(typeof key === 'string', 'STRING_KEY', key);\n  ASSERT(index >= 0, 'INDEX_UNSIGNED');\n  ASSERT(key.length === len, 'KEY_LEN', key);\n\n  const { buffer } = trie;\n\n  if (index >= len) {\n    const valuePtr = offset + TRIE_BUCKET_COUNT;\n    return buffer[valuePtr] - 1;\n  }\n\n  const c = key.charCodeAt(index) - 32; // Allow all asciis 31 < c < 130 encoded as stringified double digits\n\n  offset = buffer[offset + (c % 10)];\n  if (!offset) return TRIE_KEY_NOT_FOUND;\n\n  offset = buffer[offset + Math.floor(c / 10)];\n  if (!offset) return TRIE_KEY_NOT_FOUND;\n\n  return _trie_get(trie, offset, key, index + 1, len);\n}\n\n/**\n * See trie_get for more details\n *\n * @param {$trie} trie\n * @param {string} key\n * @returns {boolean}\n */\nfunction trie_has(trie, key) {\n  if (process.env.NODE_ENV !== 'production') ASSERT(++trie._hass);\n  return trie_get(trie, key) !== TRIE_KEY_NOT_FOUND;\n}\n\n/**\n * Find the value for given number key.\n * See trie_addNum for more details.\n *\n * @param {$trie} trie\n * @param {number} key Assumed to be an unsigned int >=0\n * @returns {number} -1 if not found, >= 0 otherwise\n */\nfunction trie_getNum(trie, key) {\n  if (process.env.NODE_ENV !== 'production') ASSERT(++trie._gets);\n  return _trie_getNum(trie, TRIE_ROOT_OFFSET, key + 1);\n}\n\n/**\n * Recursive function to search for number key\n *\n * @param {$trie} trie\n * @param {number} offset Start of a node\n * @param {number} key Assumed to be an unsigned int >=0\n * @returns {number} -1 if not found or >= 0 otherwise\n */\nfunction _trie_getNum(trie, offset, key) {\n  if (process.env.NODE_ENV !== 'production') ASSERT(++trie._getSteps);\n\n  ASSERT(offset >= 0, 'OFFSET_UNSIGNED');\n  ASSERT(typeof key === 'number', 'NUMBER_KEY');\n\n  const { buffer } = trie;\n\n  if (key === 0) {\n    const valuePtr = offset + TRIE_BUCKET_COUNT;\n    return buffer[valuePtr] - 1;\n  }\n\n  offset = buffer[offset + (key % 10)];\n  if (!offset) return TRIE_KEY_NOT_FOUND;\n\n  key = Math.floor(key / 10);\n\n  return _trie_getNum(trie, offset, key);\n}\n\n/**\n * See trie_getNum for more details\n *\n * @param {$trie} trie\n * @param {number} key Assumed to be unsigned int >= 0\n * @returns {boolean}\n */\nfunction trie_hasNum(trie, key) {\n  if (process.env.NODE_ENV !== 'production') ASSERT(++trie._hass);\n  return trie_getNum(trie, key) !== TRIE_KEY_NOT_FOUND;\n}\n\n/**\n * Human readable yay. Does not log, only returns a debug string.\n *\n * @param {$trie} trie\n * @param {boolean} [skipBuffer=false]\n * @returns {string}\n */\nfunction _trie_debug(trie, skipBuffer) {\n  if (process.env.NODE_ENV !== 'production') {\n    /* eslint no-extend-native: \"off\" */\n    const { buffer } = trie;\n\n    const { lastNode } = trie;\n\n    // Patch some es6 stuff for debugging. note: dont do this in prod, it may slow stuff down.\n    if (!String.prototype.padStart) {\n      String.prototype.padStart = function(n, c) {\n        let s = this;\n        if (this.length < n) for (let i = 0; i < n - this.length; ++i) s = c + s;\n        return s;\n      };\n    }\n\n    if (!String.prototype.padEnd) {\n      String.prototype.padEnd = function(n, c) {\n        let s = this;\n        if (this.length < n) for (let i = 0; i < n - this.length; ++i) s += c;\n        return s;\n      };\n    }\n\n    if (!Array.from) {\n      Array.from = function(a) {\n        return [].concat.call(a);\n      };\n    }\n\n    // If one doesnt support them, they probably all dont.\n    if (!Uint8Array.prototype.slice) {\n      Uint8Array.prototype.slice = Array.prototype.slice;\n      Uint16Array.prototype.slice = Array.prototype.slice;\n      Uint32Array.prototype.slice = Array.prototype.slice;\n      Float64Array.prototype.slice = Array.prototype.slice;\n    }\n\n    function bytes(b) {\n      if (b < 1024) return b + ' b';\n      b /= 1024;\n      if (b < 1024) return ~~(b * 100) / 100 + ' kb';\n      b /= 1024;\n      if (b < 1024) return ~~(b * 100) / 100 + ' mb';\n      b /= 1024;\n      return ~~(b * 100) / 100 + ' gb';\n    }\n\n    const pad = 20;\n    const npad = 6;\n    let s =\n      '' +\n      '\\n' +\n      '###\\n' +\n      'Key count:'.padEnd(pad, ' ') +\n      trie.count +\n      '\\n' +\n      'Node count:'.padEnd(pad, ' ') +\n      (lastNode / TRIE_NODE_SIZE + 1) +\n      ' (' +\n      (lastNode / TRIE_NODE_SIZE + 1) / trie.count +\n      ' nodes per key)\\n' +\n      'Buffer cell length:'.padEnd(pad, ' ') +\n      buffer.length +\n      '\\n' +\n      'Buffer byte length:'.padEnd(pad, ' ') +\n      buffer.byteLength +\n      '\\n' +\n      'Bit size:'.padEnd(pad, ' ') +\n      trie.bits +\n      '\\n' +\n      'Node len:'.padEnd(pad, ' ') +\n      TRIE_NODE_SIZE +\n      '\\n' +\n      'Node size:'.padEnd(pad, ' ') +\n      TRIE_NODE_SIZE +\n      '\\n' +\n      'Last Node:'.padEnd(pad, ' ') +\n      lastNode +\n      '\\n' +\n      'Used space:'.padEnd(pad, ' ') +\n      (lastNode + TRIE_NODE_SIZE) +\n      ' cells, ' +\n      bytes((lastNode + TRIE_NODE_SIZE) * (trie.bits >> 3)) +\n      '\\n' +\n      'Unused space:'.padEnd(pad, ' ') +\n      (buffer.length - (lastNode + TRIE_NODE_SIZE)) +\n      ' cells, ' +\n      bytes((buffer.length - (lastNode + TRIE_NODE_SIZE)) * (trie.bits >> 3)) +\n      '\\n';\n\n    if (process.env.NODE_ENV !== 'production') {\n      s +=\n        'Mallocs:'.padEnd(pad, ' ') +\n        trie._mallocs +\n        '\\n' +\n        'trie_adds:'.padEnd(pad, ' ') +\n        trie._adds +\n        '\\n' +\n        'Avg key distance:'.padEnd(pad, ' ') +\n        trie._addSteps / trie._adds +\n        '\\n' +\n        'trie_hass:'.padEnd(pad, ' ') +\n        trie._hass +\n        '\\n' +\n        'trie_gets:'.padEnd(pad, ' ') +\n        trie._gets +\n        '\\n' +\n        'Avg get distance:'.padEnd(pad, ' ') +\n        trie._getSteps +\n        ' -> ' +\n        trie._getSteps / trie._gets +\n        '\\n';\n    }\n\n    s += '\\n';\n\n    if (!skipBuffer) {\n      s +=\n        'ptr \\\\ key= 0      1      2      3      4      5      6      7      8      9  ->  value\\n\\n';\n\n      let ptr = TRIE_ROOT_OFFSET;\n      while (ptr <= lastNode) {\n        s +=\n          String(ptr).padStart(npad, ' ') +\n          ': ' +\n          [...buffer.slice(ptr, ptr + TRIE_NODE_SIZE - 1)]\n          .map(n => String(n).padStart(npad, ' '))\n          .join(', ') +\n          '  ->  ' +\n          String(buffer[ptr + TRIE_NODE_SIZE - 1]).padStart(npad, ' ') +\n          '\\n';\n        ptr += TRIE_NODE_SIZE;\n      }\n    }\n\n    s += '###\\n\\n';\n\n    return s;\n  }\n}\n\nexport {\n  TRIE_8_BIT,\n  TRIE_16_BIT,\n  TRIE_32_BIT,\n  TRIE_64_BIT,\n  TRIE_DEFAULT_BITS,\n  TRIE_DEFAULT_SIZE,\n  TRIE_INITIAL_SIZE,\n  TRIE_KEY_NOT_FOUND,\n  TRIE_MINIMAL_GROWTH,\n  TRIE_NODE_SIZE,\n  TRIE_EMPTY,\n  trie_add,\n  trie_addNum,\n  trie_create,\n  _trie_debug,\n  trie_get,\n  trie_getNum,\n  trie_getValueBitsize,\n  trie_has,\n  trie_hasNum,\n};\n"],"names":["INSPECT","require","arg","inspect","showHidden","depth","replace","o","TERM","console","setTerm","newTerm","getTerm","_doNothing","SUSH","prevTerm","log","warn","error","trace","time","timeEnd","THROW","msg","Error","join","SUB","SUP","NOT_FOUND","NO_SUCH_VALUE","Math","min","ARR_RANGE_SIZE","SMALL_MAX_NUM","SOLVED_FLAG","$STABLE","$CHANGED","$SOLVED","$REJECTED","process","env","NODE_ENV","ASSERT","bool","args","suffix","length","_stringify","Array","isArray","map","ASSERT_STRDOM","domain","expectSmallest","domain__debug","s","strdomValueLen","strdomRangeLen","lo","charCodeAt","hi","ASSERT_SOLDOM","value","undefined","ASSERT_BITDOM","ASSERT_ARRDOM","max","ASSERT_NORDOM","ASSERT_NUMDOM","ASSERT_ANYDOM","ASSERT_VARDOMS_SLOW","vardoms","LOG_NONE","LOG_STATS","LOG_SOLVES","LOG_MIN","LOG_MAX","LOG_FLAG_NONE","LOG_FLAG_PROPSTEPS","LOG_FLAG_CHOICE","LOG_FLAG_SEARCH","LOG_FLAG_SOLUTIONS","LOG_FLAGS","ASSERT_SET_LOG","level","helper_logger","ASSERT_LOG","flags","func","TRACING","isTracing","setTracing","b","TRACE","TRACE_MORPH","from","to","desc","names","indexes","TRACE_SILENT","STR_FIRST_RANGE_LO","STR_FIRST_RANGE_HI","ARR_FIRST_RANGE_LO","ARR_FIRST_RANGE_HI","MIN","MAX","FLOOR","floor","CEIL","ceil","STR_VALUE_SIZE","STR_RANGE_SIZE","EMPTY","EMPTY_STR","DOM_ZERO","domain_createValue","DOM_BOOL","domain_createRange","domain_bit_addRange","range","domain_containsValue","domain_num_containsValue","domain_str_containsValue","domain_sol_containsValue","domain_bit_containsValue","domain_str_rangeIndexOf","len","index","domain_str_decodeValue","domain_getValue","domain_num_getValue","domain_str_getValue","domain_sol_getValue","domain_bit_getValue","domain_bit_min","domain_str_encodeValue","String","fromCharCode","domain_str_encodeRange","domain_fromListToArrdom","list","slice","sort","a","arrdom","push","domain_toList","domain_num_toList","domain_str_toList","domain_sol_toList","domain_bit_toList","i","n","m","domain_getFirstIntersectingValue","domain_num_getFirstIntersectingValue","domain_str_getFirstIntersectingValue","domain_sol_getFirstIntersectingValue","domain_bit_getFirstIntersectingValue","solvedValue","indexOf","domain_str_simplify","domain_toSmallest","_domain_str_quickSortRanges","_domain_str_mergeOverlappingRanges","pivotIndex","pivotLo","pivotHi","left","right","newDomain","lasthi","lasthindex","domain_intersection","domain1","domain2","isNum1","isNum2","domain_numnum_intersection","domain_numstr_intersection","domain_strstr_intersection","sol1","sol2","domain_solsol_intersect","domain_solbit_intersect","domain_bitbit_intersect","soldom","bitdom","domain_bitToSmallest","numdom","strdom","domain_solstr_intersect","domain_bitstr_intersect","j","flag","len1","len2","index1","index2","lo1","hi1","lo2","hi2","mh","domain_intersectionValue","domain_createEmpty","domain_numToArr","domain_strToArr","domain_str_closeGaps","change","smallestRangeSize","domain_str_smallestRangeSize","_domain_str_closeGaps","gap","min_width","width","domain_mul","domain_numToStr","domain_strstr_mul","result","leni","_domain_str_mulByRange","loj","hij","domain_mulByValue","arguments","domain_divby","floorFractions","domain_strstr_divby","_domain_str_divbyRange","divisorLo","divisorHi","lenj","dividendLo","dividendHi","quotientLo","quotientHi","domain_divByValue","domain_invMul","domain_strstr_invMul","_domain_str_invMulRange","domain_invMulValue","domain_size","domain_num_size","domain_str_size","domain_bit_size","_domain_bit_size","count","domain_middleElement","domain_str_middleElement","size","targetValue","domain_min","domain_num_min","domain_str_min","domain_sol_min","stdlib","clz","clz32","_domain_bit_min","domain_max","domain_num_max","domain_str_max","domain_sol_max","domain_bit_max","_domain_bit_max","domain_arr_max","domain_isSolved","domain_isZero","domain_hasNoZero","domain_hasZero","domain_isBool","domain_isBoolyPair","domain_isBooly","domain_resolveAsBooly","domain_removeValue","domain_removeGtUnsafe","domain_isEmpty","domain_removeGte","domain_num_removeGte","domain_str_removeGte","domain_sol_removeGte","domain_bit_removeGte","slo","domain_removeLte","domain_num_removeLte","domain_str_removeLte","domain_sol_removeLte","domain_bit_removeLte","domain_removeLtUnsafe","domain_num_removeValue","domain_str_removeValue","domain_sol_removeValue","domain_bit_removeValue","lastLo","lastHi","_domain_str_removeValue","newLen","domain_strToBit","before","after","domain_sharesNoElements","domain_numnum_sharesNoElements","domain_numstr_sharesNoElements","domain_strstr_sharesNoElements","domain_solsol_sharesNoElements","domain_solbit_sharesNoElements","domain_bitbit_sharesNoElements","bitsol","domain_solstr_sharesNoElements","domain_bitstr_sharesNoElements","strIndex","strlen","numIndex","domain_num_createRange","domain_createRangeTrimmed","domain_createBoolyPair","domain_arrToSmallest","domain_numnum_createRangeZeroToMax","domain_num","domain_toArr","clone","domain_solToArr","domain_bitToArr","arr","domain_toStr","domain_arrToStr","domain_solToStr","domain_bitToStr","str","domain_numToSmallest","domain_strToSmallest","domain_anyToSmallest","out","_domain_arrToBit","domain_plus","_domain_plusWillBeSmall","_domain_plusNumNumNum","_domain_plusNumNumStr","_domain_plusNumStrStr","_domain_plusStrStrStr","domains","_domain_plusRangeStrStr","_domain_plusRangeNumStr","flagIndex","flagValue","_domain_plusRangeNumNum","loi","hii","_domain_plusRangeRangeNum","domain_str","_domain_plusRangeRangeStr","domain_minus","_domain_minusNumNum","D","_domain_minusNumStr","_domain_minusStrNumStr","_domain_minusStrStrStr","E","_domain_minusRangeStrStr","_domain_minusRangeNumNum","_domain_minusRangeNumStr","_domain_minusNumNumNum","_domain_minusRangeStrNum","_domain_minusNumStrNum","_domain_minusRangeRangeNum","_domain_minusRangeRangeStr","TRIE_ROOT_OFFSET","TRIE_BUCKET_COUNT","TRIE_NODE_SIZE","TRIE_INITIAL_SIZE","TRIE_MINIMAL_GROWTH","TRIE_KEY_NOT_FOUND","TRIE_EMPTY","TRIE_DEFAULT_SIZE","TRIE_8_BIT","TRIE_16_BIT","TRIE_32_BIT","TRIE_64_BIT","TRIE_DEFAULT_BITS","trie_create","valuesByIndex","initialLength","initialBitsize","bits","trie_getValueBitsize","buffer","trie_createBuffer","trie","_class","lastNode","_mallocs","_adds","_addSteps","_hass","_gets","_getSteps","trie_add","Uint8Array","Uint16Array","Uint32Array","Float64Array","trie_addNode","newNodePtr","trie_grow","newSize","trie_malloc","newBits","nbuf","set","key","trie_ensureValueFits","_trie_add","offset","valuePtr","curValue","c","_trie_pavePath","trie_addNum","_trie_addNum","bitsNeeded","digit","ptr","trie_get","_trie_get","trie_has","trie_getNum","_trie_getNum","trie_hasNum","_trie_debug","skipBuffer","prototype","padStart","padEnd","concat","call","bytes","pad","npad","byteLength"],"mappings":"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"}